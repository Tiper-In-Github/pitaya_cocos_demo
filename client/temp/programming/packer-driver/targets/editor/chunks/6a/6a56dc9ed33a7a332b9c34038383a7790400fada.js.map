{"version":3,"sources":["file:///Users/even/workspace/github/pitaya_cocos_demo/client/assets/scripts/net/pitaya/Pitaya.ts"],"names":["PitayaWs","proto","Pomelo","Init","host","port","Promise","reslove","reject","_ws","WebSocket","_reqId","binaryType","onopen","ev","console","log","onclose","onerror","onmessage","dispatch","msg","type","Package","TYPE_HANDSHAKE","handshake","body","TYPE_HEARTBEAT","heartbeat","TYPE_DATA","onData","TYPE_KICK","onKick","msgs","decode","Array","isArray","i","length","data","Message","route","resp","lobby","RespAuth","Call","encode","TYPE_REQUEST","pkg","send","buffer"],"mappings":"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,CAAeM,SAArC,EAAgDR,GAAhD,CAAV;;AACA,eAAKZ,GAAL,CAASwC,IAAT,CAAcD,GAAG,CAACE,MAAlB;AACH;;AA9EiB,O,GAqFtB;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAtcalD,MAAAA,Q,CACMS,G;AADNT,MAAAA,Q,CAEMW,M","sourcesContent":["import proto from \"../../../../proto_js/proto.js\";\nimport { Pomelo } from \"./Pomelo\";\n\nexport class PitayaWs {\n    private static _ws: WebSocket;\n    private static _reqId: number\n    public static async Init(host: string, port: number) {\n        return new Promise((reslove, reject) => {\n            this._ws = new WebSocket('ws://' + host + \":\" + port);\n            this._reqId = 0;\n            this._ws.binaryType = 'arraybuffer';\n            this._ws.onopen = (ev: Event) => {\n                console.log(\"websocket open\", ev)\n                reslove(ev)\n            };\n            this._ws.onclose = (ev: Event) => {\n                console.log(\"websocket close\", ev)\n                reject(ev)\n            };\n            this._ws.onerror = (ev: Event) => {\n                console.log(\"websocket err\", ev)\n                reject(ev)\n            };\n            this._ws.onmessage = (ev: any) => {\n                let dispatch = (msg: { type: number, body?: Uint8Array }) => {\n                    switch (msg.type) {\n                        case Pomelo.Package.TYPE_HANDSHAKE:\n                            this.handshake(msg.body)\n                            break\n                        case Pomelo.Package.TYPE_HEARTBEAT:\n                            this.heartbeat(msg.body)\n                            break\n                        case Pomelo.Package.TYPE_DATA:\n                            this.onData(msg.body as ArrayBuffer)\n                            break\n                        case Pomelo.Package.TYPE_KICK:\n                            this.onKick(msg.body)\n                            break\n                    }\n                }\n                let msgs = Pomelo.Package.decode(ev);\n                if (Array.isArray(msgs)) {\n                    for (let i = 0; i < msgs.length; i++) {\n                        let msg = msgs[i];\n                        dispatch(msg)\n                    }\n                    return\n                }\n                dispatch(msgs)\n            };\n        })\n    }\n\n    private static handshake(data?: ArrayBuffer) {\n\n    }\n\n    private static heartbeat(data?: ArrayBuffer) {\n\n\n    }\n\n    private static onKick(data?: ArrayBuffer) {\n\n\n    }\n\n    private static onData(data: ArrayBuffer) {\n        const msg = Pomelo.Message.decode(data);\n        if (msg.route == \"Connector.Handler.CallAuth\") {\n            let resp = proto.lobby.RespAuth.decode(msg.body)\n            console.log(\"Connector.Handler.CallAuth, resp=\", resp)\n        }\n    }\n\n\n    public static Call(route: string, data: any) {\n        this._reqId++;\n        let msg = Pomelo.Message.encode(this._reqId, Pomelo.Message.TYPE_REQUEST, 0, route, data);\n        let pkg = Pomelo.Package.encode(Pomelo.Package.TYPE_DATA, msg)\n        this._ws.send(pkg.buffer);\n    }\n\n\n}\n\n\n\n// export class Network extends EventTarget implements ISchedulable {\n\n//     // --- EventTarget begin ---\n\n//     event(name: string, data: any = null) {\n//         if (this.hasEventListener(name)) {\n//             this.emit(name, data);\n//         }\n//         else {\n//             warn('Network.passPack [' + name + '] no listener')\n//         }\n//     }\n//     // --- EventTarget end ---\n\n//     // --- instance begin ---\n//     private static _instance: Network = null;\n//     public static get instance(): Network {\n//         if (!this._instance) this._instance = new Network();\n//         return this._instance;\n//     }\n//     // --- instance end ---\n\n//     // --- ISchedulable begin ---\n//     private _id: string = null;\n//     public get uuid(): string {\n//         if (!this._id) this._id = 'Network-' + new Date().getTime();\n//         return this._id;\n//     }\n//     // --- ISchedulable end ---\n\n//     private _client: SocketClient = null;\n//     public get client(): SocketClient { return this._client; }\n\n//     private _reconnectEnable: boolean = false;\n//     private _reconnecting: boolean = false;\n//     private _reconnectAttempts: number = 0;\n\n//     private _heartbeatPassed: number = 0;\n//     private _heartbeatInterval: number = 0;\n//     private _heartbeatTimeout: number;\n//     private _shouldHeartbeat: boolean = false;\n\n//     private _requestId: number = 1;\n//     public get uniqueRequestId(): number {\n//         this._requestId++;\n//         if (this._requestId >= 40000) this._requestId = 1;\n//         return this._requestId;\n//     }\n\n//     // Map from request id to route\n//     _requestRouteMap: Map<number, number | string> = new Map();\n//     // callback from request id\n//     _requestCallbackMap: Map<number, (data: any) => void> = new Map();\n\n//     _handshakeBuffer: IHandshakeBuffer = {\n//         sys: {\n//             type: JS_WS_CLIENT_TYPE,\n//             version: JS_WS_CLIENT_VERSION,\n//             rsa: {}\n//         },\n//         user: {}\n//     };\n\n//     _routeMap: Map<string, number> = null;\n//     _routeMapBack: Map<number, string> = null;\n\n//     constructor() {\n//         super();\n//         this._client = new SocketClient(this);\n//         Scheduler.enableForTarget(this);\n//         director.getScheduler().schedule(this.heartbeatCheck, this, 0.1, macro.REPEAT_FOREVER, 0, false);\n//     }\n\n//     // --- Socket begin ---\n//     onOpen(socket: SocketClient) {\n//         if (this._reconnecting) {\n//             this.event(Events.RECONNECTED);\n//         }\n//         this.event(Events.CONNECTED);\n//         this.resetReconnect();\n//         var obj = Package.encode(Package.TYPE_HANDSHAKE, Protocol.strencode(JSON.stringify(this._handshakeBuffer)));\n//         this.client.sendBuffer(obj);\n//     }\n\n//     onRecv(socket: SocketClient, data: ArrayBuffer) {\n//         this.processPackage(Package.decode(data));\n\n//         // new package arrived, update the heartbeat timeout\n//         this.renewHeartbeatTimeout();\n//     }\n\n//     onErr(socket: SocketClient) {\n//         this.event(Events.ERROR);\n//     }\n\n//     onClose(socket: SocketClient) {\n//         this.event(Events.CLOSED);\n//         if (this._reconnectEnable && this._reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n//             this._reconnecting = true;\n//             this._reconnectAttempts++;\n//             this._connect();\n//         }\n//     }\n\n//     connectTimeout(socket: SocketClient) {\n//         this.event(Events.ERROR);\n//         if (this._reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n//             this._reconnecting = true;\n//             this._reconnectAttempts++;\n//             this._connect();\n//         }\n//     }\n//     // --- Socket end ---\n\n//     private resetReconnect() {\n//         this._reconnecting = false;\n//         this._reconnectAttempts = 0;\n//     }\n\n//     private renewHeartbeatTimeout() {\n//         this._heartbeatPassed = 0;\n//     }\n\n//     private handshake(data: ArrayBuffer) {\n//         const d: { code: number, sys: { heartbeat: number, dict: any } } = JSON.parse(Protocol.strdecode(data));\n//         if (d && d.code === RES_OLD_CLIENT) {\n//             this.event(Events.HANDSHAKEERROR);\n//             return;\n//         }\n\n//         if (d && d.code !== RES_OK) {\n//             this.event(Events.HANDSHAKEERROR);\n//             return;\n//         }\n\n//         if (d && d.sys && d.sys.heartbeat) {\n//             this._heartbeatInterval = d.sys.heartbeat;              // heartbeat interval\n//             this._heartbeatTimeout = this._heartbeatInterval * 2;   // max heartbeat timeout\n//         } else {\n//             this._heartbeatInterval = 0;\n//             this._heartbeatTimeout = 0;\n//         }\n\n//         if (d && d.sys) {\n//             const dict = d.sys.dict;\n\n//             // Init compress dict\n//             if (dict) {\n//                 this._routeMap = new Map();\n//                 this._routeMapBack = new Map();\n//                 for (const key in dict) {\n//                     if (Object.prototype.hasOwnProperty.call(dict, key)) {\n//                         const value: number = dict[key];\n//                         this._routeMap.set(key, value);\n//                         this._routeMapBack.set(value, key);\n//                     }\n//                 }\n//             }\n//         }\n\n//         this.client.sendBuffer(Package.encode(Package.TYPE_HANDSHAKE_ACK));\n//         this.event(Events.HANDSHAKEOVER);\n//     }\n\n//     private heartbeat(data: ArrayBuffer) {\n//         if (!this._heartbeatInterval) {\n//             // no heartbeat\n//             return;\n//         }\n\n//         this._shouldHeartbeat = true;\n//     }\n\n//     private heartbeatCheck(dt: number) {\n//         if (!this._heartbeatInterval) return;\n\n//         if (!this._client.isConnected) {\n//             this._heartbeatPassed = 0;\n//             return;\n//         }\n\n//         this._heartbeatPassed += dt;\n\n//         if (this._shouldHeartbeat) {\n//             if (this._heartbeatPassed > this._heartbeatInterval) {\n//                 this.client.sendBuffer(Package.encode(Package.TYPE_HEARTBEAT));\n//                 this.renewHeartbeatTimeout();\n//             }\n//             return;\n//         }\n\n//         if (this._heartbeatPassed > this._heartbeatTimeout) {\n//             console.error('server heartbeat timeout');\n//             if (this._reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n//                 this._reconnecting = true;\n//                 this._reconnectAttempts++;\n//                 this._connect();\n//             }\n//         }\n//     }\n\n//     private onData(data: ArrayBuffer) {\n//         const msg = this.decode(data);\n\n//         if (!msg) {\n//             console.error('onData decode failed');\n//             return;\n//         }\n\n//         if (msg.id) {\n//             // if have a id then find the callback function with the request\n//             var cb = this._requestCallbackMap.get(msg.id);\n//             this._requestCallbackMap.delete(msg.id);\n//             cb && cb(msg.body);\n//             return;\n//         }\n\n//         // server push message\n//         this.event(msg.route as string, msg.body);\n//     }\n\n//     onKick(data: ArrayBuffer) {\n//         data = JSON.parse(Protocol.strdecode(data));\n//         this.event(Events.BEENKICKED, data);\n//     }\n\n//     private _messageHandlers: Map<number, (data: ArrayBuffer) => void> = null;\n//     get messageHandlers(): Map<number, (data: ArrayBuffer) => void> {\n//         if (!this._messageHandlers) {\n//             this._messageHandlers = new Map();\n//             this._messageHandlers.set(Package.TYPE_HANDSHAKE, this.handshake.bind(this));\n//             this._messageHandlers.set(Package.TYPE_HEARTBEAT, this.heartbeat.bind(this));\n//             this._messageHandlers.set(Package.TYPE_DATA, this.onData.bind(this));\n//             this._messageHandlers.set(Package.TYPE_KICK, this.onKick.bind(this));\n//         }\n//         return this._messageHandlers;\n//     }\n\n//     private processPackage(msgs: { type: number, body?: Uint8Array } | { type: number, body?: Uint8Array }[]) {\n//         if (Array.isArray(msgs)) {\n//             for (var i = 0; i < msgs.length; i++) {\n//                 var msg = msgs[i];\n//                 this.messageHandlers.get(msg.type)(msg.body);\n//             }\n//         } else {\n//             this.messageHandlers.get(msgs.type)(msgs.body);\n//         }\n//     }\n\n//     private _url: string = null;\n//     private _connect(url: string = null): void {\n//         this._closeConnet();\n\n//         this._url = url || this._url;\n//         this.client.connect(this._url);\n//     }\n\n//     public static connect(url: string): void {\n//         this.instance._connect(url);\n//     }\n\n//     private _closeConnet(): void {\n//         this._reconnecting = false;\n//         this.client.close();\n//     }\n\n//     public static closeConnet(): void {\n//         this.instance._closeConnet();\n//     }\n\n//     public packProto(data: any, protoStruct: any): Uint8Array {\n//         let buffer: Uint8Array = null;\n//         if (data && protoStruct) {\n//             let message: any = null;\n//             if (protoStruct) {\n//                 message = protoStruct.create(data);\n//                 buffer = protoStruct.encode(message).finish();\n//             }\n//         }\n//         return buffer;\n//     }\n\n//     public parseProto(buffer: Uint8Array, protoStruct: any): any {\n//         let decoded: any = null;\n//         if (buffer && buffer.length && protoStruct) {\n//             try {\n//                 decoded = protoStruct.decode(buffer);\n//             }\n//             catch (e) {\n//                 console.error(e);\n//                 decoded = null;\n//             }\n//         }\n//         return decoded;\n//     }\n\n//     private decode(data: string | ArrayBuffer): {\n//         id: number,\n//         route: number | string,\n//         body: any,\n//     } {\n//         // probuff decode\n//         const msg = Message.decode(data);\n\n//         if (msg.id > 0) {\n//             msg.route = this._requestRouteMap.get(msg.id);\n//             this._requestRouteMap.delete(msg.id);\n//             if (!msg.route) {\n//                 return null;\n//             }\n//         }\n\n//         let route = msg.route;\n\n//         // Decompose route from dict\n//         if (msg.compressRoute) {\n//             route = this._routeMapBack.get(route as number);\n//             if (!route) return null;\n\n//             msg.route = route;\n//         }\n\n//         const cmd = Structs.getCmd(route as string);\n//         msg.body = this.parseProto(msg.body, cmd.server);\n//         return msg;\n//     }\n\n//     private encode(reqId: number, route: number | string, msg: any): Uint8Array {\n//         var type = reqId ? Message.TYPE_REQUEST : Message.TYPE_NOTIFY;\n\n//         const cmd = Structs.getCmd(route as string);\n//         msg = this.packProto(msg, cmd.client);\n\n//         var compressRoute = 0;\n//         if (this._routeMap.has(route as string)) {\n//             route = this._routeMap.get(route as string);\n//             compressRoute = 1;\n//         }\n\n//         return Message.encode(reqId, type, compressRoute, route, msg);\n//     }\n\n//     public _request(route: string, msg: any, cb: (data: any) => void) {\n\n//         route = route || msg.route;\n//         if (!route) {\n//             return;\n//         }\n\n//         const reqId = this.uniqueRequestId;\n\n//         this._sendMessage(reqId, route, msg);\n\n//         this._requestCallbackMap.set(reqId, cb);\n//         this._requestRouteMap.set(reqId, route);\n//     }\n\n//     public static request(route: string, msg: any, cb?: (data: any) => void) {\n//         this.instance._request(route, msg, cb);\n//     }\n\n//     private _sendMessage(reqId: number, route: number | string, msg: any): void {\n//         const message = this.encode(reqId, route, msg);\n//         this.client.sendBuffer(Package.encode(Package.TYPE_DATA, message));\n//     }\n\n//     public static notify(route: number | string, msg: any): void {\n//         this.instance._sendMessage(0, route, msg);\n//     }\n// }"]}