{"version":3,"sources":["file:///Users/even/workspace/github/pitaya_cocos_demo/client/assets/scripts/net/pitaya/Pomelo.ts"],"names":["PKG_HEAD_BYTES","MSG_FLAG_BYTES","MSG_ROUTE_CODE_BYTES","MSG_ROUTE_LEN_BYTES","MSG_ROUTE_CODE_MAX","MSG_COMPRESS_ROUTE_MASK","MSG_COMPRESS_GZIP_MASK","MSG_COMPRESS_GZIP_ENCODE_MASK","MSG_TYPE_MASK","strencode","str","Buffer","from","strdecode","buffer","toString","Package","encode","type","body","length","TYPE_DATA","alloc","index","copy","encodeBatch","bodys","i","l","typeFlag","bodyLen","decode","offset","rs","Array","undefined","push","TYPE_HANDSHAKE","TYPE_HANDSHAKE_ACK","TYPE_HEARTBEAT","TYPE_KICK","Message","id","compressRoute","route","msg","compressGzip","idBytes","msgHasId","caculateMsgIdBytes","msgLen","msgHasRoute","Error","buff","encodeMsgFlag","encodeMsgId","encodeMsgRoute","encodeMsgBody","TYPE_REQUEST","TYPE_NOTIFY","TYPE_RESPONSE","TYPE_PUSH","bytes","bytesLen","byteLength","flag","m","routeLen","len","tmp","next","Math","floor","write","Pomelo"],"mappings":";;;;;;;;;;;;;;;;;AAEI,YAAMA,cAAc,GAAG,CAAvB;AACA,YAAMC,cAAc,GAAG,CAAvB;AACA,YAAMC,oBAAoB,GAAG,CAA7B,C,CACA;;AACA,YAAMC,mBAAmB,GAAG,CAA5B;AAEA,YAAMC,kBAAkB,GAAG,MAA3B;AAEA,YAAMC,uBAAuB,GAAG,GAAhC;AACA,YAAMC,sBAAsB,GAAG,GAA/B;AACA,YAAMC,6BAA6B,GAAG,KAAK,CAA3C;AACA,YAAMC,aAAa,GAAG,GAAtB;;AAuBO,iBAASC,SAAT,CAAmBC,GAAnB,EAAwC;AAC3C,iBAAOC,MAAM,CAACC,IAAP,CAAYF,GAAZ,CAAP;AACH;;;;AAOM,iBAASG,SAAT,CAAmBC,MAAnB,EAA2C;AAC9C;AACA,iBAAOA,MAAM,CAACC,QAAP,EAAP;AACH;;;;AAEM,cAAMC,OAAN,CAAc;AAQG,iBAANC,MAAM,CAACC,IAAD,EAAeC,IAAf,EAAsC;AACtD,gBAAIC,MAAM,GAAGD,IAAI,GAAGA,IAAI,CAACC,MAAR,GAAiB,CAAlC;AACA,gBAAIN,MAAJ;;AACA,gBAAII,IAAI,KAAKF,OAAO,CAACK,SAArB,EAAgC;AAC5BP,cAAAA,MAAM,GAAGH,MAAM,CAACW,KAAP,CAAatB,cAAc,GAAGoB,MAA9B,CAAT;AACH,aAFD,MAEO;AACHA,cAAAA,MAAM,IAAIpB,cAAV;AACAc,cAAAA,MAAM,GAAGK,IAAT;AACH;;AACD,gBAAII,KAAK,GAAG,CAAZ;AACAT,YAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAkBL,IAAI,GAAG,IAAzB;AACAJ,YAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAmBH,MAAM,IAAI,EAAX,GAAiB,IAAnC;AACAN,YAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAmBH,MAAM,IAAI,CAAX,GAAgB,IAAlC;AACAN,YAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAkBH,MAAM,GAAG,IAA3B;;AACA,gBAAID,IAAI,IAAID,IAAI,KAAKF,OAAO,CAACK,SAA7B,EAAwC;AACpCF,cAAAA,IAAI,CAACK,IAAL,CAAUV,MAAV,EAAkBS,KAAlB,EAAyB,CAAzB,EAA4BH,MAA5B;AACH;;AACD,mBAAON,MAAP;AACH;;AAGwB,iBAAXW,WAAW,CAACC,KAAD,EAAiC;AACtD,gBAAIA,KAAK,CAACN,MAAN,KAAiB,CAArB,EAAwB;AACpB,qBAAO,IAAP;AACH;;AACD,gBAAIA,MAAM,GAAG,CAAb;;AACA,iBAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGF,KAAK,CAACN,MAA1B,EAAkCO,CAAC,GAAGC,CAAtC,EAAyC,EAAED,CAA3C,EAA8C;AAC1CP,cAAAA,MAAM,IAAIM,KAAK,CAACC,CAAD,CAAL,CAASP,MAAnB;AACH;;AACD,gBAAIN,MAAM,GAAGH,MAAM,CAACW,KAAP,CAAaF,MAAb,CAAb;AACA,gBAAIG,KAAK,GAAG,CAAZ;AAAA,gBAAeM,QAAQ,GAAGb,OAAO,CAACK,SAAR,GAAoB,IAA9C;;AACA,iBAAK,IAAIM,EAAC,GAAG,CAAR,EAAWC,EAAC,GAAGF,KAAK,CAACN,MAA1B,EAAkCO,EAAC,GAAGC,EAAtC,EAAyC,EAAED,EAA3C,EAA8C;AAC1C,kBAAIR,IAAI,GAAGO,KAAK,CAACC,EAAD,CAAhB;AAAA,kBAAqBG,OAAO,GAAGX,IAAI,CAACC,MAAL,GAAcpB,cAA7C;AACAc,cAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAkBM,QAAlB;AACAf,cAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAmBO,OAAO,IAAI,EAAZ,GAAkB,IAApC;AACAhB,cAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAmBO,OAAO,IAAI,CAAZ,GAAiB,IAAnC;AACAhB,cAAAA,MAAM,CAACS,KAAK,EAAN,CAAN,GAAkBO,OAAO,GAAG,IAA5B;AACAX,cAAAA,IAAI,CAACK,IAAL,CAAUV,MAAV,EAAkBS,KAAlB,EAAyB,CAAzB,EAA4BO,OAA5B;AACAP,cAAAA,KAAK,IAAIO,OAAO,GAAG,CAAnB;AACH;;AACD,mBAAOhB,MAAP;AACH;;AAImB,iBAANiB,MAAM,CAACjB,MAAD,EAAkC;AAClD,gBAAIkB,MAAM,GAAG,CAAb;AACA,gBAAIZ,MAAM,GAAG,CAAb;AACA,gBAAIa,EAAmB,GAAG,IAAIC,KAAJ,EAA1B;;AACA,mBAAOF,MAAM,GAAGlB,MAAM,CAACM,MAAvB,EAA+B;AAC3B,kBAAIF,IAAI,GAAGJ,MAAM,CAACkB,MAAM,EAAP,CAAjB;AACAZ,cAAAA,MAAM,GAAG,CAAEN,MAAM,CAACkB,MAAM,EAAP,CAAP,IAAsB,EAAtB,GAA4BlB,MAAM,CAACkB,MAAM,EAAP,CAAP,IAAsB,CAAjD,GAAqDlB,MAAM,CAACkB,MAAM,EAAP,CAA5D,MAA4E,CAArF;AACA,kBAAIb,IAAI,GAAGC,MAAM,GAAGT,MAAM,CAACW,KAAP,CAAaF,MAAb,CAAH,GAA0Be,SAA3C;;AACA,kBAAIhB,IAAJ,EAAU;AACNL,gBAAAA,MAAM,CAACU,IAAP,CAAYL,IAAZ,EAAkB,CAAlB,EAAqBa,MAArB,EAA6BA,MAAM,GAAGZ,MAAtC;AACH;;AACDY,cAAAA,MAAM,IAAIZ,MAAV;AACAa,cAAAA,EAAE,CAACG,IAAH,CAAQ;AAAElB,gBAAAA,IAAI,EAAEA,IAAR;AAAcC,gBAAAA,IAAI,EAAEA;AAApB,eAAR;AACH;;AACD,mBAAOc,EAAP;AACH;;AApEgB;;AAARjB,QAAAA,O,CACKqB,c,GAAyB,C;AAD9BrB,QAAAA,O,CAEKsB,kB,GAA6B,C;AAFlCtB,QAAAA,O,CAGKuB,c,GAAyB,C;AAH9BvB,QAAAA,O,CAIKK,S,GAAoB,C;AAJzBL,QAAAA,O,CAKKwB,S,GAAoB,C;;;AAmE/B,cAAMC,OAAN,CAAc;AAOjB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B,iBAANxB,MAAM,CAACyB,EAAD,EAAaxB,IAAb,EAA2ByB,aAA3B,EAAkDC,KAAlD,EAA0EC,GAA1E,EAAuFC,YAAvF,EAAsH;AACtI;AACA,gBAAIC,OAAO,GAAGC,QAAQ,CAAC9B,IAAD,CAAR,GAAiB+B,kBAAkB,CAACP,EAAD,CAAnC,GAA0C,CAAxD;AACA,gBAAIQ,MAAM,GAAGjD,cAAc,GAAG8C,OAA9B;;AAEA,gBAAII,WAAW,CAACjC,IAAD,CAAf,EAAuB;AACnB,kBAAIyB,aAAJ,EAAmB;AACf,oBAAI,OAAOC,KAAP,KAAiB,QAArB,EAA+B;AAC3B,wBAAM,IAAIQ,KAAJ,CAAU,8BAAV,CAAN;AACH;;AACDF,gBAAAA,MAAM,IAAIhD,oBAAV;AACH,eALD,MAKO;AACHgD,gBAAAA,MAAM,IAAI/C,mBAAV;;AACA,oBAAYyC,KAAZ,EAAmB;AACf,sBAAIS,IAAI,GAAG5C,SAAS,CAASmC,KAAT,CAApB;;AACA,sBAAIS,IAAI,CAACjC,MAAL,GAAc,GAAlB,EAAuB;AACnB,0BAAM,IAAIgC,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACDF,kBAAAA,MAAM,IAAIG,IAAI,CAACjC,MAAf;AACH;AACJ;AACJ;;AAED,gBAAIyB,GAAJ,EAAS;AACLK,cAAAA,MAAM,IAAIL,GAAG,CAACzB,MAAd;AACH;;AAED,gBAAIN,MAAM,GAAG,IAAIH,MAAJ,CAAWX,cAAc,GAAGkD,MAA5B,CAAb;AACA,gBAAIlB,MAAM,GAAGhC,cAAb,CA5BsI,CA8BtI;;AACAgC,YAAAA,MAAM,GAAGsB,aAAa,CAACpC,IAAD,EAAOyB,aAAP,EAAsB7B,MAAtB,EAA8BkB,MAA9B,EAAsCc,YAAtC,CAAtB,CA/BsI,CAiCtI;;AACA,gBAAIE,QAAQ,CAAC9B,IAAD,CAAZ,EAAoB;AAChBc,cAAAA,MAAM,GAAGuB,WAAW,CAACb,EAAD,EAAK5B,MAAL,EAAakB,MAAb,CAApB;AACH,aApCqI,CAsCtI;;;AACA,gBAAImB,WAAW,CAACjC,IAAD,CAAf,EAAuB;AACnBc,cAAAA,MAAM,GAAGwB,cAAc,CAACb,aAAD,EAAgBC,KAAhB,EAAuB9B,MAAvB,EAA+BkB,MAA/B,CAAvB;AACH,aAzCqI,CA2CtI;;;AACA,gBAAIa,GAAJ,EAAS;AACLb,cAAAA,MAAM,GAAGyB,aAAa,CAACZ,GAAD,EAAM/B,MAAN,EAAckB,MAAd,CAAtB;AACH;;AAED,mBAAOlB,MAAP;AACH;AAGD;AACR;AACA;AACA;AACA;AACA;;;AA1EyB;;AAAR2B,QAAAA,O,CACKiB,Y,GAAuB,C;AAD5BjB,QAAAA,O,CAEKkB,W,GAAsB,C;AAF3BlB,QAAAA,O,CAGKmB,a,GAAwB,C;AAH7BnB,QAAAA,O,CAIKoB,S,GAAoB,C;;AAJzBpB,QAAAA,O,CA2EKV,M,GAAS,UAAUjB,MAAV,EAAyC;AAC5D,cAAIgD,KAAK,GAAGhD,MAAZ;AACA,cAAIiD,QAAQ,GAAGD,KAAK,CAAC1C,MAAN,IAAgB0C,KAAK,CAACE,UAArC;AACA,cAAIhC,MAAM,GAAG,CAAb;AACA,cAAIU,EAAE,GAAG,CAAT;AACA,cAAIE,KAAsB,GAAG,CAA7B,CAL4D,CAO5D;;AACA,cAAIqB,IAAI,GAAGH,KAAK,CAAC9B,MAAM,EAAP,CAAhB;AACA,cAAIW,aAAa,GAAGsB,IAAI,GAAG5D,uBAA3B;AACA,cAAIa,IAAI,GAAI+C,IAAI,IAAI,CAAT,GAAczD,aAAzB;AACA,cAAIsC,YAAY,GAAImB,IAAI,IAAI,CAAT,GAAc3D,sBAAjC,CAX4D,CAa5D;;AACA,cAAI0C,QAAQ,CAAC9B,IAAD,CAAZ,EAAoB;AAChB,gBAAIgD,CAAC,GAAG,CAAR;AACA,gBAAIvC,CAAC,GAAG,CAAR;;AACA,eAAG;AACC;AACAuC,cAAAA,CAAC,GAAGJ,KAAK,CAAC9B,MAAD,CAAT;AACAU,cAAAA,EAAE,IAAI,CAACwB,CAAC,GAAG,IAAL,KAAe,IAAIvC,CAAzB;AACA,gBAAEK,MAAF;AACA,gBAAEL,CAAF;AACH,aAND,QAMSuC,CAAC,IAAI,GANd;AAOH,WAxB2D,CA0B5D;;;AACA,cAAIf,WAAW,CAACjC,IAAD,CAAf,EAAuB;AACnB,gBAAIyB,aAAJ,EAAmB;AACfC,cAAAA,KAAK,GAAIkB,KAAK,CAAC9B,MAAM,EAAP,CAAN,IAAqB,CAArB,GAAyB8B,KAAK,CAAC9B,MAAM,EAAP,CAAtC;AACH,aAFD,MAEO;AACH,kBAAImC,QAAQ,GAAGL,KAAK,CAAC9B,MAAM,EAAP,CAApB;AACAY,cAAAA,KAAK,GAAGkB,KAAK,CAAC/C,QAAN,CAAe,QAAf,EAAyBiB,MAAzB,EAAiCA,MAAM,GAAGmC,QAA1C,CAAR;AACAnC,cAAAA,MAAM,IAAImC,QAAV;AACH;AACJ,WAnC2D,CAqC5D;;;AACA,cAAIrC,OAAO,GAAGiC,QAAQ,GAAG/B,MAAzB;AACA,cAAIb,IAAI,GAAGR,MAAM,CAACW,KAAP,CAAaQ,OAAb,CAAX;AAEAgC,UAAAA,KAAK,CAACtC,IAAN,CAAWL,IAAX,EAAiB,CAAjB,EAAoBa,MAApB,EAA4BA,MAAM,GAAGF,OAArC;AAEA,iBAAO;AAAEY,YAAAA,EAAF;AAAMxB,YAAAA,IAAN;AAAYyB,YAAAA,aAAZ;AAA2BC,YAAAA,KAA3B;AAAkCzB,YAAAA,IAAlC;AAAwC2B,YAAAA;AAAxC,WAAP;AACH,S;;;;AAGL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKI,iBAASE,QAAT,CAAkB9B,IAAlB,EAAgC;AAC5B,iBAAOA,IAAI,KAAKuB,OAAO,CAACiB,YAAjB,IAAiCxC,IAAI,KAAKuB,OAAO,CAACmB,aAAzD;AACH;;AAED,iBAAST,WAAT,CAAqBjC,IAArB,EAAmC;AAC/B,iBAAOA,IAAI,KAAKuB,OAAO,CAACiB,YAAjB,IAAiCxC,IAAI,KAAKuB,OAAO,CAACkB,WAAlD,IACHzC,IAAI,KAAKuB,OAAO,CAACoB,SADrB;AAEH;;AAED,iBAASZ,kBAAT,CAA4BP,EAA5B,EAAwC;AACpC,cAAI0B,GAAG,GAAG,CAAV;;AACA,aAAG;AACCA,YAAAA,GAAG,IAAI,CAAP;AACA1B,YAAAA,EAAE,KAAK,CAAP;AACH,WAHD,QAGSA,EAAE,GAAG,CAHd;;AAIA,iBAAO0B,GAAP;AACH;;AAED,iBAASd,aAAT,CAAuBpC,IAAvB,EAAqCyB,aAArC,EAA4D7B,MAA5D,EAA4EkB,MAA5E,EAA4Fc,YAA5F,EAAmH;AAC/G,cAAI5B,IAAI,KAAKuB,OAAO,CAACiB,YAAjB,IAAiCxC,IAAI,KAAKuB,OAAO,CAACkB,WAAlD,IACAzC,IAAI,KAAKuB,OAAO,CAACmB,aADjB,IACkC1C,IAAI,KAAKuB,OAAO,CAACoB,SADvD,EACkE;AAC9D,kBAAM,IAAIT,KAAJ,CAAU,0BAA0BlC,IAApC,CAAN;AACH;;AAEDJ,UAAAA,MAAM,CAACkB,MAAD,CAAN,GAAkBd,IAAI,IAAI,CAAT,IAAeyB,aAAa,GAAG,CAAH,GAAO,CAAnC,CAAjB;;AAEA,cAAIG,YAAJ,EAAkB;AACdhC,YAAAA,MAAM,CAACkB,MAAD,CAAN,GAAiBlB,MAAM,CAACkB,MAAD,CAAN,GAAiBzB,6BAAlC;AACH;;AAED,iBAAOyB,MAAM,GAAG/B,cAAhB;AACH;;AAED,iBAASsD,WAAT,CAAqBb,EAArB,EAAiC5B,MAAjC,EAAiDkB,MAAjD,EAAiE;AAC7D,aAAG;AACC,gBAAIqC,GAAG,GAAG3B,EAAE,GAAG,GAAf;AACA,gBAAI4B,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAW9B,EAAE,GAAG,GAAhB,CAAX;;AAEA,gBAAI4B,IAAI,KAAK,CAAb,EAAgB;AACZD,cAAAA,GAAG,GAAGA,GAAG,GAAG,GAAZ;AACH;;AACDvD,YAAAA,MAAM,CAACkB,MAAM,EAAP,CAAN,GAAmBqC,GAAnB;AAEA3B,YAAAA,EAAE,GAAG4B,IAAL;AACH,WAVD,QAUS5B,EAAE,KAAK,CAVhB;;AAYA,iBAAOV,MAAP;AACH;;AAED,iBAASwB,cAAT,CAAwBb,aAAxB,EAA+CC,KAA/C,EAAuE9B,MAAvE,EAAuFkB,MAAvF,EAAuG;AACnG,cAAIW,aAAJ,EAAmB;AACf,gBAAIC,KAAK,GAAGxC,kBAAZ,EAAgC;AAC5B,oBAAM,IAAIgD,KAAJ,CAAU,0BAAV,CAAN;AACH;;AAEDtC,YAAAA,MAAM,CAACkB,MAAM,EAAP,CAAN,GAA6BY,KAAT,IAAmB,CAApB,GAAyB,IAA5C;AACA9B,YAAAA,MAAM,CAACkB,MAAM,EAAP,CAAN,GAA4BY,KAAT,GAAkB,IAArC;AACH,WAPD,MAOO;AACH,gBAAIA,KAAJ,EAAW;AACP9B,cAAAA,MAAM,CAACkB,MAAM,EAAP,CAAN,GAA4BY,KAAT,CAAgBxB,MAAhB,GAAyB,IAA5C;AACAN,cAAAA,MAAM,CAAC2D,KAAP,CAAqB7B,KAArB,EAA4BZ,MAA5B,EAA6CY,KAAT,CAAgBxB,MAApD,EAA4D,QAA5D;AACAY,cAAAA,MAAM,IAAaY,KAAT,CAAgBxB,MAA1B;AACH,aAJD,MAIO;AACHN,cAAAA,MAAM,CAACkB,MAAM,EAAP,CAAN,GAAmB,CAAnB;AACH;AACJ;;AAED,iBAAOA,MAAP;AACH;;AAED,iBAASyB,aAAT,CAAuBZ,GAAvB,EAAoC/B,MAApC,EAAoDkB,MAApD,EAAoE;AAChEa,UAAAA,GAAG,CAACrB,IAAJ,CAASV,MAAT,EAAiBkB,MAAjB,EAAyB,CAAzB,EAA4Ba,GAAG,CAACzB,MAAhC;AACA,iBAAOY,MAAM,GAAGa,GAAG,CAACzB,MAApB;AACH;SAvVYsD,M,sBAAAA,M","sourcesContent":["export namespace Pomelo {\n\n    const PKG_HEAD_BYTES = 4;\n    const MSG_FLAG_BYTES = 1;\n    const MSG_ROUTE_CODE_BYTES = 2;\n    //const MSG_ID_MAX_BYTES = 5;\n    const MSG_ROUTE_LEN_BYTES = 1;\n\n    const MSG_ROUTE_CODE_MAX = 0xffff;\n\n    const MSG_COMPRESS_ROUTE_MASK = 0x1;\n    const MSG_COMPRESS_GZIP_MASK = 0x1;\n    const MSG_COMPRESS_GZIP_ENCODE_MASK = 1 << 4;\n    const MSG_TYPE_MASK = 0x7;\n\n    interface IMsgDecResult {\n        id: number,\n        type: number,\n        compressRoute: number,\n        route: string | number,\n        body: Buffer,\n        compressGzip: number\n    }\n\n    interface IPackage {\n        type: number,\n        body?: Buffer \n    }\n\n    /**\n     * pomele client encode\n     * id message id;\n     * route message route\n     * msg message body\n     * socketio current support string\n     */\n    export function strencode(str: string): Buffer {\n        return Buffer.from(str);\n    }\n\n    /**\n     * client decode\n     * msg String data\n     * return Message Object\n     */\n    export function strdecode(buffer: Buffer): string {\n        // encoding defaults to 'utf8'\n        return buffer.toString();\n    }\n\n    export class Package {\n        public static TYPE_HANDSHAKE: number = 1;\n        public static TYPE_HANDSHAKE_ACK: number = 2;\n        public static TYPE_HEARTBEAT: number = 3;\n        public static TYPE_DATA: number = 4;\n        public static TYPE_KICK: number = 5;\n\n\n        public static encode(type: number, body?: Buffer): Buffer {\n            var length = body ? body.length : 0;\n            var buffer: Buffer\n            if (type !== Package.TYPE_DATA) {\n                buffer = Buffer.alloc(PKG_HEAD_BYTES + length);\n            } else {\n                length -= PKG_HEAD_BYTES;\n                buffer = body as Buffer;\n            }\n            var index = 0;\n            buffer[index++] = type & 0xff;\n            buffer[index++] = (length >> 16) & 0xff;\n            buffer[index++] = (length >> 8) & 0xff;\n            buffer[index++] = length & 0xff;\n            if (body && type !== Package.TYPE_DATA) {\n                body.copy(buffer, index, 0, length);\n            }\n            return buffer;\n        }\n\n\n        public static encodeBatch(bodys: Buffer[]): Buffer | null {\n            if (bodys.length === 0) {\n                return null;\n            }\n            let length = 0\n            for (let i = 0, l = bodys.length; i < l; ++i) {\n                length += bodys[i].length\n            }\n            let buffer = Buffer.alloc(length)\n            let index = 0, typeFlag = Package.TYPE_DATA & 0xff\n            for (let i = 0, l = bodys.length; i < l; ++i) {\n                let body = bodys[i], bodyLen = body.length - PKG_HEAD_BYTES;\n                buffer[index++] = typeFlag;\n                buffer[index++] = (bodyLen >> 16) & 0xff;\n                buffer[index++] = (bodyLen >> 8) & 0xff;\n                buffer[index++] = bodyLen & 0xff;\n                body.copy(buffer, index, 4, bodyLen);\n                index += bodyLen - 4;\n            }\n            return buffer;\n        }\n\n\n\n        public static decode(buffer: Buffer): Array<IPackage> {\n            var offset = 0;\n            var length = 0;\n            var rs: Array<IPackage> = new Array<IPackage>();\n            while (offset < buffer.length) {\n                var type = buffer[offset++];\n                length = ((buffer[offset++]) << 16 | (buffer[offset++]) << 8 | buffer[offset++]) >>> 0;\n                var body = length ? Buffer.alloc(length) : undefined;\n                if (body) {\n                    buffer.copy(body, 0, offset, offset + length);\n                }\n                offset += length;\n                rs.push({ type: type, body: body });\n            }\n            return rs;\n        }\n\n    }\n\n    export class Message {\n        public static TYPE_REQUEST: number = 0;\n        public static TYPE_NOTIFY: number = 1;\n        public static TYPE_RESPONSE: number = 2;\n        public static TYPE_PUSH: number = 3;\n\n\n        /**\n         * Message protocol encode.\n         *\n         * @param  id            message id\n         * @param  type          message type\n         * @param  compressRoute whether compress route\n         * @param  route         route code or route string\n         * @param  msg           message body bytes\n         * @return               encode result\n         */\n        public static encode(id: number, type: number, compressRoute: number, route: number | string, msg: Buffer, compressGzip?: number): Buffer {\n            // caculate message max length\n            var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;\n            var msgLen = MSG_FLAG_BYTES + idBytes;\n\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    if (typeof route !== 'number') {\n                        throw new Error('error flag for number route!');\n                    }\n                    msgLen += MSG_ROUTE_CODE_BYTES;\n                } else {\n                    msgLen += MSG_ROUTE_LEN_BYTES;\n                    if (<string>route) {\n                        let buff = strencode(<string>route);\n                        if (buff.length > 255) {\n                            throw new Error('route maxlength is overflow');\n                        }\n                        msgLen += buff.length;\n                    }\n                }\n            }\n\n            if (msg) {\n                msgLen += msg.length;\n            }\n\n            var buffer = new Buffer(PKG_HEAD_BYTES + msgLen);\n            var offset = PKG_HEAD_BYTES;\n\n            // add flag\n            offset = encodeMsgFlag(type, compressRoute, buffer, offset, compressGzip);\n\n            // add message id\n            if (msgHasId(type)) {\n                offset = encodeMsgId(id, buffer, offset);\n            }\n\n            // add route\n            if (msgHasRoute(type)) {\n                offset = encodeMsgRoute(compressRoute, route, buffer, offset);\n            }\n\n            // add body\n            if (msg) {\n                offset = encodeMsgBody(msg, buffer, offset);\n            }\n\n            return buffer;\n        }\n\n\n        /**\n         * Message protocol decode.\n         *\n         * @param   buffer message bytes\n         * @return         message object\n         */\n        public static decode = function (buffer: Buffer): IMsgDecResult {\n            var bytes = buffer;\n            var bytesLen = bytes.length || bytes.byteLength;\n            var offset = 0;\n            var id = 0;\n            var route: string | number = 0;\n\n            // parse flag\n            var flag = bytes[offset++];\n            var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;\n            var type = (flag >> 1) & MSG_TYPE_MASK;\n            var compressGzip = (flag >> 4) & MSG_COMPRESS_GZIP_MASK;\n\n            // parse id\n            if (msgHasId(type)) {\n                var m = 0;\n                var i = 0;\n                do {\n                    //m = parseInt(bytes[offset]);\n                    m = bytes[offset];\n                    id += (m & 0x7f) << (7 * i);\n                    ++offset;\n                    ++i;\n                } while (m >= 128);\n            }\n\n            // parse route\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    route = (bytes[offset++]) << 8 | bytes[offset++];\n                } else {\n                    var routeLen = bytes[offset++];\n                    route = bytes.toString('binary', offset, offset + routeLen);\n                    offset += routeLen;\n                }\n            }\n\n            // parse body\n            var bodyLen = bytesLen - offset;\n            var body = Buffer.alloc(bodyLen);\n\n            bytes.copy(body, 0, offset, offset + bodyLen);\n\n            return { id, type, compressRoute, route, body, compressGzip }\n        }\n    }\n\n    /**\n     * Package protocol encode.\n     *\n     * Pomelo package format:\n     * +------+-------------+------------------+\n     * | type | body length |       body       |\n     * +------+-------------+------------------+\n     *\n     * Head: 4bytes\n     *   0: package type,\n     *      1 - handshake,\n     *      2 - handshake ack,\n     *      3 - heartbeat,\n     *      4 - data\n     *      5 - kick\n     *   1 - 3: big-endian body length\n     * Body: body length bytes\n     *\n     * @param  {Number}    type   package type\n     * @param  {ByteArray} body   body content in bytes\n     * @return {ByteArray}        new byte array that contains encode result\n     */\n\n\n\n\n    function msgHasId(type: number) {\n        return type === Message.TYPE_REQUEST || type === Message.TYPE_RESPONSE;\n    }\n\n    function msgHasRoute(type: number) {\n        return type === Message.TYPE_REQUEST || type === Message.TYPE_NOTIFY ||\n            type === Message.TYPE_PUSH;\n    }\n\n    function caculateMsgIdBytes(id: number) {\n        var len = 0;\n        do {\n            len += 1;\n            id >>= 7;\n        } while (id > 0);\n        return len;\n    }\n\n    function encodeMsgFlag(type: number, compressRoute: number, buffer: Buffer, offset: number, compressGzip?: number) {\n        if (type !== Message.TYPE_REQUEST && type !== Message.TYPE_NOTIFY &&\n            type !== Message.TYPE_RESPONSE && type !== Message.TYPE_PUSH) {\n            throw new Error('unkonw message type: ' + type);\n        }\n\n        buffer[offset] = (type << 1) | (compressRoute ? 1 : 0);\n\n        if (compressGzip) {\n            buffer[offset] = buffer[offset] | MSG_COMPRESS_GZIP_ENCODE_MASK;\n        }\n\n        return offset + MSG_FLAG_BYTES;\n    }\n\n    function encodeMsgId(id: number, buffer: Buffer, offset: number) {\n        do {\n            var tmp = id % 128;\n            var next = Math.floor(id / 128);\n\n            if (next !== 0) {\n                tmp = tmp + 128;\n            }\n            buffer[offset++] = tmp;\n\n            id = next;\n        } while (id !== 0);\n\n        return offset;\n    }\n\n    function encodeMsgRoute(compressRoute: number, route: string | number, buffer: Buffer, offset: number) {\n        if (compressRoute) {\n            if (route > MSG_ROUTE_CODE_MAX) {\n                throw new Error('route number is overflow');\n            }\n\n            buffer[offset++] = ((<number>route) >> 8) & 0xff;\n            buffer[offset++] = (<number>route) & 0xff;\n        } else {\n            if (route) {\n                buffer[offset++] = (<string>route).length & 0xff;\n                buffer.write(<string>route, offset, (<string>route).length, 'binary');\n                offset += (<string>route).length;\n            } else {\n                buffer[offset++] = 0;\n            }\n        }\n\n        return offset;\n    }\n\n    function encodeMsgBody(msg: Buffer, buffer: Buffer, offset: number) {\n        msg.copy(buffer, offset, 0, msg.length);\n        return offset + msg.length;\n    }\n}"]}