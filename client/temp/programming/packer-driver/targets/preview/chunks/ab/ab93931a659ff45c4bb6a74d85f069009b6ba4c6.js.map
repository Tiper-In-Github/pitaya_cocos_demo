{"version":3,"sources":["file:///Users/even/workspace/github/pitaya_cocos_demo/client/assets/scripts/net/pitaya/Pomelo.ts"],"names":["PKG_HEAD_BYTES","MSG_FLAG_BYTES","MSG_ROUTE_CODE_BYTES","MSG_ROUTE_LEN_BYTES","MSG_ROUTE_CODE_MAX","MSG_COMPRESS_ROUTE_MASK","MSG_COMPRESS_GZIP_MASK","MSG_COMPRESS_GZIP_ENCODE_MASK","MSG_TYPE_MASK","strencode","str","byteArray","Uint8Array","length","offset","i","charCode","charCodeAt","codes","j","_buffer","copyArray","dest","doffset","src","soffset","index","strdecode","buffer","bytes","array","end","push","String","fromCharCode","apply","Package","encode","type","body","decode","rs","Array","Buffer","alloc","TYPE_HANDSHAKE","TYPE_HANDSHAKE_ACK","TYPE_HEARTBEAT","TYPE_DATA","TYPE_KICK","Message","id","compressRoute","route","msg","compressGzip","idBytes","msgHasId","caculateMsgIdBytes","msgLen","msgHasRoute","Error","routeBuffer","encodeMsgFlag","encodeMsgId","encodeMsgRoute","encodeMsgBody","TYPE_REQUEST","TYPE_NOTIFY","TYPE_RESPONSE","TYPE_PUSH","bytesLen","byteLength","flag","m","routeLen","toString","bodyLen","copy","len","tmp","next","Math","floor","Pomelo"],"mappings":"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","sourcesContent":["export namespace Pomelo {\n\n    const PKG_HEAD_BYTES = 4;\n    const MSG_FLAG_BYTES = 1;\n    const MSG_ROUTE_CODE_BYTES = 2;\n    //const MSG_ID_MAX_BYTES = 5;\n    const MSG_ROUTE_LEN_BYTES = 1;\n\n    const MSG_ROUTE_CODE_MAX = 0xffff;\n\n    const MSG_COMPRESS_ROUTE_MASK = 0x1;\n    const MSG_COMPRESS_GZIP_MASK = 0x1;\n    const MSG_COMPRESS_GZIP_ENCODE_MASK = 1 << 4;\n    const MSG_TYPE_MASK = 0x7;\n\n    interface IMsgDecResult {\n        id: number,\n        type: number,\n        compressRoute: number,\n        route: string | number,\n        body: Buffer,\n        compressGzip: number\n    }\n\n    interface IPackage {\n        type: number,\n        body?: Uint8Array\n    }\n\n    /**\n     * pomele client encode\n     * id message id;\n     * route message route\n     * msg message body\n     * socketio current support string\n     */\n    export function strencode(str: string): Uint8Array {\n        // return Buffer.from(str);\n        var byteArray = new Uint8Array(str.length * 3);\n        var offset = 0;\n        for (var i = 0; i < str.length; i++) {\n            var charCode = str.charCodeAt(i);\n            var codes = null;\n            if (charCode <= 0x7f) {\n                codes = [charCode];\n            } else if (charCode <= 0x7ff) {\n                codes = [0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f)];\n            } else {\n                codes = [0xe0 | (charCode >> 12), 0x80 | ((charCode & 0xfc0) >> 6), 0x80 | (charCode & 0x3f)];\n            }\n            for (var j = 0; j < codes.length; j++) {\n                byteArray[offset] = codes[j];\n                ++offset;\n            }\n        }\n        var _buffer =  new Uint8Array(offset);\n        copyArray(_buffer, 0, byteArray, 0, offset);\n        return _buffer;\n    }\n\n    export function copyArray(dest: any, doffset: number, src: any, soffset: number, length: number) {\n        for (var index = 0; index < length; index++) {\n            dest[doffset++] = src[soffset++];\n        }\n    };\n\n    /**\n     * client decode\n     * msg String data\n     * return Message Object\n     */\n    export function strdecode(buffer: Uint8Array): string {\n        var bytes = new Uint8Array(buffer);\n        var array = [];\n        var offset = 0;\n        var charCode = 0;\n        var end = bytes.length;\n        while (offset < end) {\n            if (bytes[offset] < 128) {\n                charCode = bytes[offset];\n                offset += 1;\n            } else if (bytes[offset] < 224) {\n                charCode = ((bytes[offset] & 0x3f) << 6) + (bytes[offset + 1] & 0x3f);\n                offset += 2;\n            } else {\n                charCode = ((bytes[offset] & 0x0f) << 12) + ((bytes[offset + 1] & 0x3f) << 6) + (bytes[offset + 2] & 0x3f);\n                offset += 3;\n            }\n            array.push(charCode);\n        }\n        return String.fromCharCode.apply(null, array);\n    }\n\n    export class Package {\n        public static TYPE_HANDSHAKE: number = 1;\n        public static TYPE_HANDSHAKE_ACK: number = 2;\n        public static TYPE_HEARTBEAT: number = 3;\n        public static TYPE_DATA: number = 4;\n        public static TYPE_KICK: number = 5;\n\n\n        public static encode(type: number, body?: Buffer): Uint8Array {\n            var length = body ? body.length : 0;\n            var buffer = new Uint8Array(PKG_HEAD_BYTES + length);\n            var index = 0;\n            buffer[index++] = type & 0xff;\n            buffer[index++] = (length >> 16) & 0xff;\n            buffer[index++] = (length >> 8) & 0xff;\n            buffer[index++] = length & 0xff;\n            if (body) {\n                copyArray(buffer, index, body, 0, length);\n            }\n            return buffer;\n        }\n\n\n\n\n\n        public static decode(buffer: Buffer): IPackage | Array<IPackage> {\n            var offset = 0;\n            var bytes = new Uint8Array(buffer);\n            var length = 0;\n            var rs = new Array<IPackage>();\n            while (offset < bytes.length) {\n                var type = bytes[offset++];\n                length = ((bytes[offset++]) << 16 | (bytes[offset++]) << 8 | bytes[offset++]) >>> 0;\n                var body = length ?  Buffer.alloc(length) :  Buffer.alloc(0);\n                copyArray(body, 0, bytes, offset, length);\n                offset += length;\n                rs.push({ type: type, body: body });\n            }\n            return rs.length === 1 ? rs[0] : rs;\n        }\n\n    }\n\n\n    export class Message {\n        public static TYPE_REQUEST: number = 0;\n        public static TYPE_NOTIFY: number = 1;\n        public static TYPE_RESPONSE: number = 2;\n        public static TYPE_PUSH: number = 3;\n\n\n        /**\n       * Message protocol encode.\n       *\n       * @param  {Number} id            message id\n       * @param  {Number} type          message type\n       * @param  {Number} compressRoute whether compress route\n       * @param  {Number|String} route  route code or route string\n       * @param  {Buffer} msg           message body bytes\n       * @return {Buffer}               encode result\n       */\n        public static encode(id: number, type: number, compressRoute: number, route: number | string, msg: Buffer, compressGzip?: number): Buffer {\n\n            var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;\n            var msgLen = MSG_FLAG_BYTES + idBytes;\n\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    if (typeof route !== 'number') {\n                        throw new Error('error flag for number route!');\n                    }\n                    msgLen += MSG_ROUTE_CODE_BYTES;\n                } else {\n                    msgLen += MSG_ROUTE_LEN_BYTES;\n                    if (route) {\n                        let routeBuffer = strencode(<string>route);\n                        if (routeBuffer.length > 255) {\n                            throw new Error('route maxlength is overflow');\n                        }\n                        msgLen += routeBuffer.length;\n                    }\n                }\n            }\n\n            if (msg) {\n                msgLen += msg.length;\n            }\n\n            var buffer =  Buffer.alloc(msgLen);\n            var offset = 0;\n\n            // add flag\n            offset = encodeMsgFlag(type, compressRoute, buffer, offset);\n\n            // add message id\n            if (msgHasId(type)) {\n                offset = encodeMsgId(id, buffer, offset);\n            }\n\n            // add route\n            if (msgHasRoute(type)) {\n                offset = encodeMsgRoute(compressRoute, route, buffer, offset);\n            }\n\n            // add body\n            if (msg) {\n                offset = encodeMsgBody(msg, buffer, offset);\n            }\n\n            return buffer;\n        }\n\n\n        /**\n         * Message protocol decode.\n         *\n         * @param   buffer message bytes\n         * @return         message object\n         */\n        public static decode = function (buffer: Buffer): IMsgDecResult {\n            var bytes = buffer;\n            var bytesLen = bytes.length || bytes.byteLength;\n            var offset = 0;\n            var id = 0;\n            var route: string | number = 0;\n\n            // parse flag\n            var flag = bytes[offset++];\n            var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;\n            var type = (flag >> 1) & MSG_TYPE_MASK;\n            var compressGzip = (flag >> 4) & MSG_COMPRESS_GZIP_MASK;\n\n            // parse id\n            if (msgHasId(type)) {\n                var m = 0;\n                var i = 0;\n                do {\n                    //m = parseInt(bytes[offset]);\n                    m = bytes[offset];\n                    id += (m & 0x7f) << (7 * i);\n                    ++offset;\n                    ++i;\n                } while (m >= 128);\n            }\n\n            // parse route\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    route = (bytes[offset++]) << 8 | bytes[offset++];\n                } else {\n                    var routeLen = bytes[offset++];\n                    route = bytes.toString('binary', offset, offset + routeLen);\n                    offset += routeLen;\n                }\n            }\n\n            // parse body\n            var bodyLen = bytesLen - offset;\n            var body = Buffer.alloc(bodyLen);\n\n            bytes.copy(body, 0, offset, offset + bodyLen);\n\n            return { id, type, compressRoute, route, body, compressGzip }\n        }\n    }\n\n\n\n    export function msgHasId(type: number) {\n        return type === Message.TYPE_REQUEST || type === Message.TYPE_RESPONSE;\n    };\n\n    export function msgHasRoute(type: number) {\n        return type === Message.TYPE_REQUEST || type === Message.TYPE_NOTIFY ||\n            type === Message.TYPE_PUSH;\n    };\n\n    export function caculateMsgIdBytes(id: number) {\n        var len = 0;\n        do {\n            len += 1;\n            id >>= 7;\n        } while (id > 0);\n        return len;\n    };\n\n    export function encodeMsgFlag(type: number, compressRoute: number, buffer: Uint8Array, offset: number) {\n        if (type !== Message.TYPE_REQUEST && type !== Message.TYPE_NOTIFY &&\n            type !== Message.TYPE_RESPONSE && type !== Message.TYPE_PUSH) {\n            throw new Error('unkonw message type: ' + type);\n        }\n\n        buffer[offset] = (type << 1) | (compressRoute ? 1 : 0);\n\n        return offset + MSG_FLAG_BYTES;\n    };\n\n    export function encodeMsgId(id: number, buffer: Uint8Array, offset: number) {\n        do {\n            var tmp = id % 128;\n            var next = Math.floor(id / 128);\n\n            if (next !== 0) {\n                tmp = tmp + 128;\n            }\n            buffer[offset++] = tmp;\n\n            id = next;\n        } while (id !== 0);\n\n        return offset;\n    };\n\n    export function encodeMsgRoute(compressRoute: number, route: any, buffer: Buffer, offset: number) {\n        if (compressRoute) {\n            // if (route > MSG_ROUTE_CODE_MAX) {\n            //     throw new Error('route number is overflow');\n            // }\n            // buffer[offset++] = (route >> 8) & 0xff;\n            // buffer[offset++] = route & 0xff;\n        } else {\n            if (route) {\n                buffer[offset++] = route.length & 0xff;\n                copyArray(buffer, offset, route, 0, route.length);\n                offset += route.length;\n            } else {\n                buffer[offset++] = 0;\n            }\n        }\n\n        return offset;\n    };\n\n    export function encodeMsgBody(msg: Buffer, buffer: Buffer, offset: number) {\n        copyArray(buffer, offset, msg, 0, msg.length);\n        return offset + msg.length;\n    };\n}"]}