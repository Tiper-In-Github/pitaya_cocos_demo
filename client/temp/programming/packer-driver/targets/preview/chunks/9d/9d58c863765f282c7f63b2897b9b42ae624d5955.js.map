{"version":3,"sources":["file:///Users/even/workspace/github/pitaya_cocos_demo/client/assets/scripts/net/pitaya/Pomelo.ts"],"names":["PKG_HEAD_BYTES","MSG_FLAG_BYTES","MSG_ROUTE_CODE_BYTES","MSG_ID_MAX_BYTES","MSG_ROUTE_LEN_BYTES","MSG_ROUTE_CODE_MAX","MSG_COMPRESS_ROUTE_MASK","MSG_COMPRESS_GZIP_MASK","MSG_COMPRESS_GZIP_ENCODE_MASK","MSG_TYPE_MASK","Protocol","strencode","str","byteArray","Uint8Array","length","offset","i","charCode","charCodeAt","codes","j","_buffer","copyArray","strdecode","buffer","bytes","array","end","push","String","fromCharCode","apply","Package","encode","type","body","index","decode","rs","undefined","TYPE_HANDSHAKE","TYPE_HANDSHAKE_ACK","TYPE_HEARTBEAT","TYPE_DATA","TYPE_KICK","Message","id","compressRoute","route","msg","idBytes","msgHasId","caculateMsgIdBytes","msgLen","msgHasRoute","Error","routeBuffer","encodeMsgFlag","encodeMsgId","encodeMsgRoute","encodeMsgBody","TextEncoder","bytesLen","byteLength","flag","compressGzip","m","parseInt","routeLen","routeByte","bodyLen","TYPE_REQUEST","TYPE_NOTIFY","TYPE_RESPONSE","TYPE_PUSH","dest","doffset","src","soffset","len","tmp","next","Math","floor","Pomelo"],"mappings":";;;;;;;;;;;;;;;;;AAGI,YAAIA,cAAc,GAAG,CAArB;AACA,YAAIC,cAAc,GAAG,CAArB;AACA,YAAIC,oBAAoB,GAAG,CAA3B;AACA,YAAIC,gBAAgB,GAAG,CAAvB;AACA,YAAIC,mBAAmB,GAAG,CAA1B;AAEA,YAAIC,kBAAkB,GAAG,MAAzB;AAEA,YAAIC,uBAAuB,GAAG,GAA9B;AACA,YAAIC,sBAAsB,GAAG,GAA7B;AACA,YAAIC,6BAA6B,GAAG,KAAK,CAAzC;AACA,YAAIC,aAAa,GAAG,GAApB;;AAEO,cAAMC,QAAN,CAAe;AAElB;AACR;AACA;AACA;AACA;AACA;AACA;AACwB,iBAATC,SAAS,CAACC,GAAD,EAA0B;AACtC,gBAAIC,SAAS,GAAG,IAAIC,UAAJ,CAAeF,GAAG,CAACG,MAAJ,GAAa,CAA5B,CAAhB;AACA,gBAAIC,MAAM,GAAG,CAAb;;AACA,iBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAAG,CAACG,MAAxB,EAAgCE,CAAC,EAAjC,EAAqC;AACjC,kBAAIC,QAAQ,GAAGN,GAAG,CAACO,UAAJ,CAAeF,CAAf,CAAf;AACA,kBAAIG,KAAK,GAAG,IAAZ;;AACA,kBAAIF,QAAQ,IAAI,IAAhB,EAAsB;AAClBE,gBAAAA,KAAK,GAAG,CAACF,QAAD,CAAR;AACH,eAFD,MAEO,IAAIA,QAAQ,IAAI,KAAhB,EAAuB;AAC1BE,gBAAAA,KAAK,GAAG,CAAC,OAAQF,QAAQ,IAAI,CAArB,EAAyB,OAAQA,QAAQ,GAAG,IAA5C,CAAR;AACH,eAFM,MAEA;AACHE,gBAAAA,KAAK,GAAG,CAAC,OAAQF,QAAQ,IAAI,EAArB,EAA0B,OAAQ,CAACA,QAAQ,GAAG,KAAZ,KAAsB,CAAxD,EAA4D,OAAQA,QAAQ,GAAG,IAA/E,CAAR;AACH;;AACD,mBAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACL,MAA1B,EAAkCM,CAAC,EAAnC,EAAuC;AACnCR,gBAAAA,SAAS,CAACG,MAAD,CAAT,GAAoBI,KAAK,CAACC,CAAD,CAAzB;AACA,kBAAEL,MAAF;AACH;AACJ;;AACD,gBAAIM,OAAO,GAAG,IAAIR,UAAJ,CAAeE,MAAf,CAAd;;AACAO,YAAAA,SAAS,CAACD,OAAD,EAAU,CAAV,EAAaT,SAAb,EAAwB,CAAxB,EAA2BG,MAA3B,CAAT;AACA,mBAAOM,OAAP;AACH;AAED;AACR;AACA;AACA;AACA;;;AACwB,iBAATE,SAAS,CAACC,MAAD,EAA8B;AAC1C,gBAAIC,KAAK,GAAG,IAAIZ,UAAJ,CAAeW,MAAf,CAAZ;AACA,gBAAIE,KAAK,GAAG,EAAZ;AACA,gBAAIX,MAAM,GAAG,CAAb;AACA,gBAAIE,QAAQ,GAAG,CAAf;AACA,gBAAIU,GAAG,GAAGF,KAAK,CAACX,MAAhB;;AACA,mBAAOC,MAAM,GAAGY,GAAhB,EAAqB;AACjB,kBAAIF,KAAK,CAACV,MAAD,CAAL,GAAgB,GAApB,EAAyB;AACrBE,gBAAAA,QAAQ,GAAGQ,KAAK,CAACV,MAAD,CAAhB;AACAA,gBAAAA,MAAM,IAAI,CAAV;AACH,eAHD,MAGO,IAAIU,KAAK,CAACV,MAAD,CAAL,GAAgB,GAApB,EAAyB;AAC5BE,gBAAAA,QAAQ,GAAG,CAAC,CAACQ,KAAK,CAACV,MAAD,CAAL,GAAgB,IAAjB,KAA0B,CAA3B,KAAiCU,KAAK,CAACV,MAAM,GAAG,CAAV,CAAL,GAAoB,IAArD,CAAX;AACAA,gBAAAA,MAAM,IAAI,CAAV;AACH,eAHM,MAGA;AACHE,gBAAAA,QAAQ,GAAG,CAAC,CAACQ,KAAK,CAACV,MAAD,CAAL,GAAgB,IAAjB,KAA0B,EAA3B,KAAkC,CAACU,KAAK,CAACV,MAAM,GAAG,CAAV,CAAL,GAAoB,IAArB,KAA8B,CAAhE,KAAsEU,KAAK,CAACV,MAAM,GAAG,CAAV,CAAL,GAAoB,IAA1F,CAAX;AACAA,gBAAAA,MAAM,IAAI,CAAV;AACH;;AACDW,cAAAA,KAAK,CAACE,IAAN,CAAWX,QAAX;AACH;;AACD,mBAAOY,MAAM,CAACC,YAAP,CAAoBC,KAApB,CAA0B,IAA1B,EAAgCL,KAAhC,CAAP;AACH;;AAzDiB;;;;AA4Df,cAAMM,OAAN,CAAc;AAOjB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqB,iBAANC,MAAM,CAACC,IAAD,EAAeC,IAAf,EAA8C;AACvD,gBAAIrB,MAAM,GAAGqB,IAAI,GAAGA,IAAI,CAACrB,MAAR,GAAiB,CAAlC;AACA,gBAAIU,MAAM,GAAG,IAAIX,UAAJ,CAAed,cAAc,GAAGe,MAAhC,CAAb;AACA,gBAAIsB,KAAK,GAAG,CAAZ;AACAZ,YAAAA,MAAM,CAACY,KAAK,EAAN,CAAN,GAAkBF,IAAI,GAAG,IAAzB;AACAV,YAAAA,MAAM,CAACY,KAAK,EAAN,CAAN,GAAmBtB,MAAM,IAAI,EAAX,GAAiB,IAAnC;AACAU,YAAAA,MAAM,CAACY,KAAK,EAAN,CAAN,GAAmBtB,MAAM,IAAI,CAAX,GAAgB,IAAlC;AACAU,YAAAA,MAAM,CAACY,KAAK,EAAN,CAAN,GAAkBtB,MAAM,GAAG,IAA3B;;AACA,gBAAIqB,IAAJ,EAAU;AACNb,cAAAA,SAAS,CAACE,MAAD,EAASY,KAAT,EAAgBD,IAAhB,EAAsB,CAAtB,EAAyBrB,MAAzB,CAAT;AACH;;AACD,mBAAOU,MAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACqB,iBAANa,MAAM,CAACb,MAAD,EAAmG;AAC5G,gBAAIT,MAAM,GAAG,CAAb;AACA,gBAAIU,KAAK,GAAG,IAAIZ,UAAJ,CAAeW,MAAf,CAAZ;AACA,gBAAIV,MAAM,GAAG,CAAb;AACA,gBAAIwB,EAAE,GAAG,EAAT;;AACA,mBAAOvB,MAAM,GAAGU,KAAK,CAACX,MAAtB,EAA8B;AAC1B,kBAAIoB,IAAI,GAAGT,KAAK,CAACV,MAAM,EAAP,CAAhB;AACAD,cAAAA,MAAM,GAAG,CAAEW,KAAK,CAACV,MAAM,EAAP,CAAN,IAAqB,EAArB,GAA2BU,KAAK,CAACV,MAAM,EAAP,CAAN,IAAqB,CAA/C,GAAmDU,KAAK,CAACV,MAAM,EAAP,CAAzD,MAAyE,CAAlF;AACA,kBAAIoB,IAAI,GAAGrB,MAAM,GAAG,IAAID,UAAJ,CAAeC,MAAf,CAAH,GAA4ByB,SAA7C;;AACA,kBAAIJ,IAAJ,EAAU;AACNb,gBAAAA,SAAS,CAACa,IAAD,EAAO,CAAP,EAAUV,KAAV,EAAiBV,MAAjB,EAAyBD,MAAzB,CAAT;AACH;;AACDC,cAAAA,MAAM,IAAID,MAAV;AACAwB,cAAAA,EAAE,CAACV,IAAH,CAAQ;AAAE,wBAAQM,IAAV;AAAgB,wBAAQC;AAAxB,eAAR;AACH;;AACD,mBAAOG,EAAE,CAACxB,MAAH,KAAc,CAAd,GAAkBwB,EAAE,CAAC,CAAD,CAApB,GAA0BA,EAAjC;AACH;;AAlEgB;;AAARN,QAAAA,O,CACFQ,c,GAAiB,C;AADfR,QAAAA,O,CAEFS,kB,GAAqB,C;AAFnBT,QAAAA,O,CAGFU,c,GAAiB,C;AAHfV,QAAAA,O,CAIFW,S,GAAY,C;AAJVX,QAAAA,O,CAKFY,S,GAAY,C;;;AAgEhB,cAAMC,OAAN,CAAc;AAMjB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqB,iBAANZ,MAAM,CAACa,EAAD,EAAaZ,IAAb,EAA2Ba,aAA3B,EAAkDC,KAAlD,EAA0EC,GAA1E,EAAuG;AAChH;AACA,gBAAIC,OAAO,GAAGC,QAAQ,CAACjB,IAAD,CAAR,GAAiBkB,kBAAkB,CAACN,EAAD,CAAnC,GAA0C,CAAxD;AACA,gBAAIO,MAAM,GAAGrD,cAAc,GAAGkD,OAA9B;;AAEA,gBAAII,WAAW,CAACpB,IAAD,CAAf,EAAuB;AACnB,kBAAIa,aAAJ,EAAmB;AACf,oBAAI,OAAOC,KAAP,KAAiB,QAArB,EAA+B;AAC3B,wBAAM,IAAIO,KAAJ,CAAU,8BAAV,CAAN;AACH;;AACDF,gBAAAA,MAAM,IAAIpD,oBAAV;AACH,eALD,MAKO;AACHoD,gBAAAA,MAAM,IAAIlD,mBAAV;;AACA,oBAAI6C,KAAJ,EAAW;AACP;AACA;AACA;AACA;AACA;AAEA,sBAAKQ,WAAW,GAAG/C,QAAQ,CAACC,SAAT,CAAmBsC,KAAnB,CAAnB;;AACA,sBAAIQ,WAAW,CAAC1C,MAAZ,GAAqB,GAAzB,EAA8B;AAC1B,0BAAM,IAAIyC,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACDF,kBAAAA,MAAM,IAAIG,WAAW,CAAC1C,MAAtB;AACH;AACJ;AACJ;;AAED,gBAAImC,GAAJ,EAAS;AACLI,cAAAA,MAAM,IAAIJ,GAAG,CAACnC,MAAd;AACH;;AAED,gBAAIU,MAAM,GAAG,IAAIX,UAAJ,CAAewC,MAAf,CAAb;AACA,gBAAItC,MAAM,GAAG,CAAb,CAlCgH,CAoChH;;AACAA,YAAAA,MAAM,GAAG0C,aAAa,CAACvB,IAAD,EAAOa,aAAP,EAAsBvB,MAAtB,EAA8BT,MAA9B,CAAtB,CArCgH,CAuChH;;AACA,gBAAIoC,QAAQ,CAACjB,IAAD,CAAZ,EAAoB;AAChBnB,cAAAA,MAAM,GAAG2C,WAAW,CAACZ,EAAD,EAAKtB,MAAL,EAAaT,MAAb,CAApB;AACH,aA1C+G,CA4ChH;;;AACA,gBAAIuC,WAAW,CAACpB,IAAD,CAAf,EAAuB;AACnBnB,cAAAA,MAAM,GAAG4C,cAAc,CAACZ,aAAD,EAAgBC,KAAhB,EAAuBxB,MAAvB,EAA+BT,MAA/B,CAAvB;AACH,aA/C+G,CAiDhH;;;AACA,gBAAIkC,GAAJ,EAAS;AACLlC,cAAAA,MAAM,GAAG6C,aAAa,CAACX,GAAD,EAAMzB,MAAN,EAAcT,MAAd,CAAtB;AACH;;AAED,mBAAOS,MAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACqB,iBAANa,MAAM,CAACb,MAAD,EAOX;AACE,gBAAIC,KAAK,GAAG,OAAOD,MAAP,IAAiB,QAAjB,GAA4B,IAAIqC,WAAJ,GAAkB5B,MAAlB,CAAyBT,MAAzB,CAA5B,GAA+D,IAAIX,UAAJ,CAAeW,MAAf,CAA3E;AACA,gBAAIsC,QAAQ,GAAGrC,KAAK,CAACX,MAAN,IAAgBW,KAAK,CAACsC,UAArC;AACA,gBAAIhD,MAAM,GAAG,CAAb;AACA,gBAAI+B,EAAE,GAAG,CAAT;AACA,gBAAIE,KAAsB,GAAG,EAA7B,CALF,CAOE;;AACA,gBAAIgB,IAAI,GAAGvC,KAAK,CAACV,MAAM,EAAP,CAAhB;AACA,gBAAIgC,aAAa,GAAGiB,IAAI,GAAG3D,uBAA3B;AACA,gBAAI6B,IAAI,GAAI8B,IAAI,IAAI,CAAT,GAAcxD,aAAzB;AACA,gBAAIyD,YAAY,GAAID,IAAI,IAAI,CAAT,GAAc1D,sBAAjC,CAXF,CAaE;;AACA,gBAAI6C,QAAQ,CAACjB,IAAD,CAAZ,EAAoB;AAChB,kBAAIgC,CAAC,GAAG,CAAR;AACA,kBAAIlD,CAAC,GAAG,CAAR;;AACA,iBAAG;AACCkD,gBAAAA,CAAC,GAAGC,QAAQ,CAAC1C,KAAK,CAACV,MAAD,CAAL,GAAgB,EAAjB,CAAZ;AACA+B,gBAAAA,EAAE,IAAI,CAACoB,CAAC,GAAG,IAAL,KAAe,IAAIlD,CAAzB;AACAD,gBAAAA,MAAM;AACNC,gBAAAA,CAAC;AACJ,eALD,QAKSkD,CAAC,IAAI,GALd;AAMH,aAvBH,CAyBE;;;AACA,gBAAIZ,WAAW,CAACpB,IAAD,CAAf,EAAuB;AACnB,kBAAIa,aAAJ,EAAmB;AACfC,gBAAAA,KAAK,GAAIvB,KAAK,CAACV,MAAM,EAAP,CAAN,IAAqB,CAArB,GAAyBU,KAAK,CAACV,MAAM,EAAP,CAAtC;AACH,eAFD,MAEO;AACH,oBAAIqD,QAAQ,GAAG3C,KAAK,CAACV,MAAM,EAAP,CAApB;;AACA,oBAAIqD,QAAJ,EAAc;AACV,sBAAIC,SAAS,GAAG,IAAIxD,UAAJ,CAAeuD,QAAf,CAAhB;AACA9C,kBAAAA,SAAS,CAAC+C,SAAD,EAAY,CAAZ,EAAe5C,KAAf,EAAsBV,MAAtB,EAA8BqD,QAA9B,CAAT;AACApB,kBAAAA,KAAK,GAAGvC,QAAQ,CAACc,SAAT,CAAmB8C,SAAnB,CAAR;AACH,iBAJD,MAIO;AACHrB,kBAAAA,KAAK,GAAG,EAAR;AACH;;AACDjC,gBAAAA,MAAM,IAAIqD,QAAV;AACH;AACJ,aAxCH,CA0CE;;;AACA,gBAAIE,OAAO,GAAGR,QAAQ,GAAG/C,MAAzB;AACA,gBAAIoB,IAAI,GAAG,IAAItB,UAAJ,CAAeyD,OAAf,CAAX;AAEAhD,YAAAA,SAAS,CAACa,IAAD,EAAO,CAAP,EAAUV,KAAV,EAAiBV,MAAjB,EAAyBuD,OAAzB,CAAT;AAEA,mBAAO;AACHxB,cAAAA,EAAE,EAAEA,EADD;AAEHZ,cAAAA,IAAI,EAAEA,IAFH;AAGHa,cAAAA,aAAa,EAAEA,aAHZ;AAIHC,cAAAA,KAAK,EAAEA,KAJJ;AAKHb,cAAAA,IAAI,EAAEA,IALH;AAMH8B,cAAAA,YAAY,EAAEA;AANX,aAAP;AAQH;;AA9IgB;;AAARpB,QAAAA,O,CACF0B,Y,GAAe,C;AADb1B,QAAAA,O,CAEF2B,W,GAAc,C;AAFZ3B,QAAAA,O,CAGF4B,a,GAAgB,C;AAHd5B,QAAAA,O,CAIF6B,S,GAAY,C;;;AA6IvB,iBAASpD,SAAT,CAAmBqD,IAAnB,EAAqCC,OAArC,EAAsDC,GAAtD,EAAgFC,OAAhF,EAAiGhE,MAAjG,EAAuH;AACnH;AACA,cAAI,OAAO+D,GAAP,IAAc,QAAlB,EAA4B;AACxB,iBAAK,IAAIzC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGtB,MAA5B,EAAoCsB,KAAK,EAAzC,EAA6C;AACzCuC,cAAAA,IAAI,CAACC,OAAO,EAAR,CAAJ,GAAkBT,QAAQ,CAACU,GAAG,CAACC,OAAO,EAAR,CAAJ,CAA1B;AACH;AACJ,WAJD,MAKK;AACD,iBAAK,IAAI1C,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGtB,MAA5B,EAAoCsB,KAAK,EAAzC,EAA6C;AACzCuC,cAAAA,IAAI,CAACC,OAAO,EAAR,CAAJ,GAAkBC,GAAG,CAACC,OAAO,EAAR,CAArB;AACH;AACJ;AACJ;;AAAA;;AAED,iBAAS3B,QAAT,CAAkBjB,IAAlB,EAAyC;AACrC,iBAAOA,IAAI,KAAKW,OAAO,CAAC0B,YAAjB,IAAiCrC,IAAI,KAAKW,OAAO,CAAC4B,aAAzD;AACH;;AAAA;;AAED,iBAASnB,WAAT,CAAqBpB,IAArB,EAA4C;AACxC,iBAAOA,IAAI,KAAKW,OAAO,CAAC0B,YAAjB,IAAiCrC,IAAI,KAAKW,OAAO,CAAC2B,WAAlD,IACHtC,IAAI,KAAKW,OAAO,CAAC6B,SADrB;AAEH;;AAAA;;AAED,iBAAStB,kBAAT,CAA4BN,EAA5B,EAAgD;AAC5C,cAAIiC,GAAG,GAAG,CAAV;;AACA,aAAG;AACCA,YAAAA,GAAG,IAAI,CAAP;AACAjC,YAAAA,EAAE,KAAK,CAAP;AACH,WAHD,QAGSA,EAAE,GAAG,CAHd;;AAIA,iBAAOiC,GAAP;AACH;;AAAA;;AAED,iBAAStB,aAAT,CAAuBvB,IAAvB,EAAqCa,aAArC,EAA4DvB,MAA5D,EAAgFT,MAAhF,EAAwG;AACpG,cAAImB,IAAI,KAAKW,OAAO,CAAC0B,YAAjB,IAAiCrC,IAAI,KAAKW,OAAO,CAAC2B,WAAlD,IACAtC,IAAI,KAAKW,OAAO,CAAC4B,aADjB,IACkCvC,IAAI,KAAKW,OAAO,CAAC6B,SADvD,EACkE;AAC9D,kBAAM,IAAInB,KAAJ,CAAU,0BAA0BrB,IAApC,CAAN;AACH;;AAEDV,UAAAA,MAAM,CAACT,MAAD,CAAN,GAAkBmB,IAAI,IAAI,CAAT,IAAea,aAAa,GAAG,CAAH,GAAO,CAAnC,CAAjB;AAIA,iBAAOhC,MAAM,GAAGf,cAAhB;AACH;;AAAA;;AAED,iBAAS0D,WAAT,CAAqBZ,EAArB,EAAiCtB,MAAjC,EAAqDT,MAArD,EAA6E;AACzE,aAAG;AACC,gBAAIiE,GAAG,GAAGlC,EAAE,GAAG,GAAf;AACA,gBAAImC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWrC,EAAE,GAAG,GAAhB,CAAX;;AAEA,gBAAImC,IAAI,KAAK,CAAb,EAAgB;AACZD,cAAAA,GAAG,GAAGA,GAAG,GAAG,GAAZ;AACH;;AACDxD,YAAAA,MAAM,CAACT,MAAM,EAAP,CAAN,GAAmBiE,GAAnB;AAEAlC,YAAAA,EAAE,GAAGmC,IAAL;AACH,WAVD,QAUSnC,EAAE,KAAK,CAVhB;;AAYA,iBAAO/B,MAAP;AACH;;AAAA;;AAED,iBAAS4C,cAAT,CAAwBZ,aAAxB,EAA+CC,KAA/C,EAAuExB,MAAvE,EAA2FT,MAA3F,EAAmH;AAC/G,cAAIgC,aAAJ,EAAmB;AAEf,gBAAIC,KAAK,GAAG5C,kBAAZ,EAAgC;AAC5B,oBAAM,IAAImD,KAAJ,CAAU,0BAAV,CAAN;AACH;;AAED/B,YAAAA,MAAM,CAACT,MAAM,EAAP,CAAN,GAAoBiC,KAAK,IAAc,CAApB,GAAyB,IAA5C;AACAxB,YAAAA,MAAM,CAACT,MAAM,EAAP,CAAN,GAAmBiC,KAAnB;AACH,WARD,MAQO;AACH,gBAAIA,KAAJ,EAAW;AACPxB,cAAAA,MAAM,CAACT,MAAM,EAAP,CAAN,GAAoBiC,KAAD,CAAkBlC,MAAlB,GAA2B,IAA9C;AACAQ,cAAAA,SAAS,CAACE,MAAD,EAAST,MAAT,EAAiBiC,KAAjB,EAAkC,CAAlC,EAAsCA,KAAD,CAAkBlC,MAAvD,CAAT;AACAC,cAAAA,MAAM,IAAKiC,KAAD,CAAkBlC,MAA5B;AACH,aAJD,MAIO;AACHU,cAAAA,MAAM,CAACT,MAAM,EAAP,CAAN,GAAmB,CAAnB;AACH;AACJ;;AAED,iBAAOA,MAAP;AACH;;AAAA;;AAED,iBAAS6C,aAAT,CAAuBX,GAAvB,EAAwCzB,MAAxC,EAA4DT,MAA5D,EAAoF;AAChFO,UAAAA,SAAS,CAACE,MAAD,EAAST,MAAT,EAAiBkC,GAAjB,EAAsB,CAAtB,EAAyBA,GAAG,CAACnC,MAA7B,CAAT;AACA,iBAAOC,MAAM,GAAGkC,GAAG,CAACnC,MAApB;AACH;;AAAA;SAvXYsE,M,sBAAAA,M","sourcesContent":["\nexport namespace Pomelo {\n\n    var PKG_HEAD_BYTES = 4;\n    var MSG_FLAG_BYTES = 1;\n    var MSG_ROUTE_CODE_BYTES = 2;\n    var MSG_ID_MAX_BYTES = 5;\n    var MSG_ROUTE_LEN_BYTES = 1;\n\n    var MSG_ROUTE_CODE_MAX = 0xffff;\n\n    var MSG_COMPRESS_ROUTE_MASK = 0x1;\n    var MSG_COMPRESS_GZIP_MASK = 0x1;\n    var MSG_COMPRESS_GZIP_ENCODE_MASK = 1 << 4;\n    var MSG_TYPE_MASK = 0x7;\n\n    export class Protocol {\n\n        /**\n         * pomele client encode\n         * id message id;\n         * route message route\n         * msg message body\n         * socketio current support string\n         */\n        static strencode(str: string): Uint8Array {\n            var byteArray = new Uint8Array(str.length * 3);\n            var offset = 0;\n            for (var i = 0; i < str.length; i++) {\n                var charCode = str.charCodeAt(i);\n                var codes = null;\n                if (charCode <= 0x7f) {\n                    codes = [charCode];\n                } else if (charCode <= 0x7ff) {\n                    codes = [0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f)];\n                } else {\n                    codes = [0xe0 | (charCode >> 12), 0x80 | ((charCode & 0xfc0) >> 6), 0x80 | (charCode & 0x3f)];\n                }\n                for (var j = 0; j < codes.length; j++) {\n                    byteArray[offset] = codes[j];\n                    ++offset;\n                }\n            }\n            var _buffer = new Uint8Array(offset);\n            copyArray(_buffer, 0, byteArray, 0, offset);\n            return _buffer;\n        }\n\n        /**\n         * client decode\n         * msg String data\n         * return Message Object\n         */\n        static strdecode(buffer: ArrayBuffer): string {\n            var bytes = new Uint8Array(buffer);\n            var array = [];\n            var offset = 0;\n            var charCode = 0;\n            var end = bytes.length;\n            while (offset < end) {\n                if (bytes[offset] < 128) {\n                    charCode = bytes[offset];\n                    offset += 1;\n                } else if (bytes[offset] < 224) {\n                    charCode = ((bytes[offset] & 0x1f) << 6) + (bytes[offset + 1] & 0x3f);\n                    offset += 2;\n                } else {\n                    charCode = ((bytes[offset] & 0x0f) << 12) + ((bytes[offset + 1] & 0x3f) << 6) + (bytes[offset + 2] & 0x3f);\n                    offset += 3;\n                }\n                array.push(charCode);\n            }\n            return String.fromCharCode.apply(null, array);\n        }\n    }\n\n    export class Package {\n        static TYPE_HANDSHAKE = 1;\n        static TYPE_HANDSHAKE_ACK = 2;\n        static TYPE_HEARTBEAT = 3;\n        static TYPE_DATA = 4;\n        static TYPE_KICK = 5;\n\n        /**\n         * Package protocol encode.\n         *\n         * Pomelo package format:\n         * +------+-------------+------------------+\n         * | type | body length |       body       |\n         * +------+-------------+------------------+\n         *\n         * Head: 4bytes\n         *   0: package type,\n         *      1 - handshake,\n         *      2 - handshake ack,\n         *      3 - heartbeat,\n         *      4 - data\n         *      5 - kick\n         *   1 - 3: big-endian body length\n         * Body: body length bytes\n         *\n         * @param  {Number}    type   package type\n         * @param  {Uint8Array} body   body content in bytes\n         * @return {Uint8Array}        new byte array that contains encode result\n         */\n        static encode(type: number, body?: Uint8Array): Uint8Array {\n            var length = body ? body.length : 0;\n            var buffer = new Uint8Array(PKG_HEAD_BYTES + length);\n            var index = 0;\n            buffer[index++] = type & 0xff;\n            buffer[index++] = (length >> 16) & 0xff;\n            buffer[index++] = (length >> 8) & 0xff;\n            buffer[index++] = length & 0xff;\n            if (body) {\n                copyArray(buffer, index, body, 0, length);\n            }\n            return buffer;\n        }\n\n        /**\n         * Package protocol decode.\n         * See encode for package format.\n         *\n         * @param  {Uint8Array} buffer byte array containing package content\n         * @return {Object}           {type: package type, buffer: body byte array}\n         */\n        static decode(buffer: ArrayBuffer): { type: number, body?: Uint8Array } | { type: number, body?: Uint8Array }[] {\n            var offset = 0;\n            var bytes = new Uint8Array(buffer);\n            var length = 0;\n            var rs = [];\n            while (offset < bytes.length) {\n                var type = bytes[offset++];\n                length = ((bytes[offset++]) << 16 | (bytes[offset++]) << 8 | bytes[offset++]) >>> 0;\n                var body = length ? new Uint8Array(length) : undefined;\n                if (body) {\n                    copyArray(body, 0, bytes, offset, length);\n                }\n                offset += length;\n                rs.push({ 'type': type, 'body': body });\n            }\n            return rs.length === 1 ? rs[0] : rs;\n        }\n    }\n\n    export class Message {\n        static TYPE_REQUEST = 0;\n        static TYPE_NOTIFY = 1;\n        static TYPE_RESPONSE = 2;\n        static TYPE_PUSH = 3;\n\n        /**\n         * Message protocol encode.\n         *\n         * @param  {Number} id            message id\n         * @param  {Number} type          message type\n         * @param  {Number} compressRoute whether compress route\n         * @param  {Number|String} route  route code or route string\n         * @param  {Buffer} msg           message body bytes\n         * @return {Buffer}               encode result\n         */\n        static encode(id: number, type: number, compressRoute: number, route: number | string, msg: Uint8Array): Uint8Array {\n            // caculate message max length\n            var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;\n            var msgLen = MSG_FLAG_BYTES + idBytes;\n\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    if (typeof route !== 'number') {\n                        throw new Error('error flag for number route!');\n                    }\n                    msgLen += MSG_ROUTE_CODE_BYTES;\n                } else {\n                    msgLen += MSG_ROUTE_LEN_BYTES;\n                    if (route) {\n                        // route = Protocol.strencode(route);\n                        // if (route.length > 255) {\n                        //     throw new Error('route maxlength is overflow');\n                        // }\n                        // msgLen += route.length;\n\n                        let  routeBuffer = Protocol.strencode(route as string);\n                        if (routeBuffer.length > 255) {\n                            throw new Error('route maxlength is overflow');\n                        }\n                        msgLen += routeBuffer.length;\n                    }\n                }\n            }\n\n            if (msg) {\n                msgLen += msg.length;\n            }\n\n            var buffer = new Uint8Array(msgLen);\n            var offset = 0;\n\n            // add flag\n            offset = encodeMsgFlag(type, compressRoute, buffer, offset);\n\n            // add message id\n            if (msgHasId(type)) {\n                offset = encodeMsgId(id, buffer, offset);\n            }\n\n            // add route\n            if (msgHasRoute(type)) {\n                offset = encodeMsgRoute(compressRoute, route, buffer, offset);\n            }\n\n            // add body\n            if (msg) {\n                offset = encodeMsgBody(msg, buffer, offset);\n            }\n\n            return buffer;\n        }\n\n        /**\n         * Message protocol decode.\n         *\n         * @param  {Buffer|Uint8Array} buffer message bytes\n         * @return {Object}            message object\n         */\n        static decode(buffer: string | ArrayBuffer): {\n            id: number,\n            type: number,\n            compressRoute: number,\n            route: number | string,\n            body: Uint8Array,\n            compressGzip: number\n        } {\n            var bytes = typeof buffer == 'string' ? new TextEncoder().encode(buffer) : new Uint8Array(buffer);\n            var bytesLen = bytes.length || bytes.byteLength;\n            var offset = 0;\n            var id = 0;\n            var route: number | string = '';\n\n            // parse flag\n            var flag = bytes[offset++];\n            var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;\n            var type = (flag >> 1) & MSG_TYPE_MASK;\n            var compressGzip = (flag >> 4) & MSG_COMPRESS_GZIP_MASK;\n\n            // parse id\n            if (msgHasId(type)) {\n                var m = 0;\n                var i = 0;\n                do {\n                    m = parseInt(bytes[offset] + '');\n                    id += (m & 0x7f) << (7 * i);\n                    offset++;\n                    i++;\n                } while (m >= 128);\n            }\n\n            // parse route\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    route = (bytes[offset++]) << 8 | bytes[offset++];\n                } else {\n                    var routeLen = bytes[offset++];\n                    if (routeLen) {\n                        let routeByte = new Uint8Array(routeLen);\n                        copyArray(routeByte, 0, bytes, offset, routeLen);\n                        route = Protocol.strdecode(routeByte);\n                    } else {\n                        route = '';\n                    }\n                    offset += routeLen;\n                }\n            }\n\n            // parse body\n            var bodyLen = bytesLen - offset;\n            var body = new Uint8Array(bodyLen);\n\n            copyArray(body, 0, bytes, offset, bodyLen);\n\n            return {\n                id: id,\n                type: type,\n                compressRoute: compressRoute,\n                route: route,\n                body: body,\n                compressGzip: compressGzip\n            }\n        }\n    }\n\n    function copyArray(dest: Uint8Array, doffset: number, src: Uint8Array | string, soffset: number, length: number): void {\n        // Uint8Array\n        if (typeof src == 'string') {\n            for (var index = 0; index < length; index++) {\n                dest[doffset++] = parseInt(src[soffset++]);\n            }\n        }\n        else {\n            for (var index = 0; index < length; index++) {\n                dest[doffset++] = src[soffset++];\n            }\n        }\n    };\n\n    function msgHasId(type: number): boolean {\n        return type === Message.TYPE_REQUEST || type === Message.TYPE_RESPONSE;\n    };\n\n    function msgHasRoute(type: number): boolean {\n        return type === Message.TYPE_REQUEST || type === Message.TYPE_NOTIFY ||\n            type === Message.TYPE_PUSH;\n    };\n\n    function caculateMsgIdBytes(id: number): number {\n        var len = 0;\n        do {\n            len += 1;\n            id >>= 7;\n        } while (id > 0);\n        return len;\n    };\n\n    function encodeMsgFlag(type: number, compressRoute: number, buffer: Uint8Array, offset: number): number {\n        if (type !== Message.TYPE_REQUEST && type !== Message.TYPE_NOTIFY &&\n            type !== Message.TYPE_RESPONSE && type !== Message.TYPE_PUSH) {\n            throw new Error('unkonw message type: ' + type);\n        }\n\n        buffer[offset] = (type << 1) | (compressRoute ? 1 : 0);\n\n\n\n        return offset + MSG_FLAG_BYTES;\n    };\n\n    function encodeMsgId(id: number, buffer: Uint8Array, offset: number): number {\n        do {\n            var tmp = id % 128;\n            var next = Math.floor(id / 128);\n\n            if (next !== 0) {\n                tmp = tmp + 128;\n            }\n            buffer[offset++] = tmp;\n\n            id = next;\n        } while (id !== 0);\n\n        return offset;\n    };\n\n    function encodeMsgRoute(compressRoute: number, route: number | string, buffer: Uint8Array, offset: number): number {\n        if (compressRoute) {\n\n            if (route > MSG_ROUTE_CODE_MAX) {\n                throw new Error('route number is overflow');\n            }\n\n            buffer[offset++] = (route as number >> 8) & 0xff;\n            buffer[offset++] = route as number & 0xff;\n        } else {\n            if (route) {\n                buffer[offset++] = (route as string).length & 0xff;\n                copyArray(buffer, offset, route as string, 0, (route as string).length);\n                offset += (route as string).length;\n            } else {\n                buffer[offset++] = 0;\n            }\n        }\n\n        return offset;\n    };\n\n    function encodeMsgBody(msg: Uint8Array, buffer: Uint8Array, offset: number): number {\n        copyArray(buffer, offset, msg, 0, msg.length);\n        return offset + msg.length;\n    };\n}\n\n\n\n// export namespace Pomelo {\n\n//     export class Events {\n//         public static CONNECTED: string = 'pomelo.network.connected';\n//         public static RECONNECTED: string = 'pomelo.network.reconnected';\n//         public static CLOSED: string = 'pomelo.network.closed';\n//         public static ERROR: string = 'pomelo.network.error';\n//         public static HANDSHAKEERROR: string = 'pomelo.network.handshakeerror';\n//         public static HANDSHAKEOVER: string = 'pomelo.network.handshakeover';\n//         public static BEENKICKED: string = 'pomelo.network.beenkicked';\n//     }\n\n//     var PKG_HEAD_BYTES = 4;\n//     var MSG_FLAG_BYTES = 1;\n//     var MSG_ROUTE_CODE_BYTES = 2;\n//     var MSG_ID_MAX_BYTES = 5;\n//     var MSG_ROUTE_LEN_BYTES = 1;\n\n//     var MSG_ROUTE_CODE_MAX = 0xffff;\n\n//     var MSG_COMPRESS_ROUTE_MASK = 0x1;\n//     var MSG_COMPRESS_GZIP_MASK = 0x1;\n//     var MSG_COMPRESS_GZIP_ENCODE_MASK = 1 << 4;\n//     var MSG_TYPE_MASK = 0x7;\n\n//     export class Protocol {\n\n//         /**\n//          * pomele client encode\n//          * id message id;\n//          * route message route\n//          * msg message body\n//          * socketio current support string\n//          */\n//         static strencode(str: string): Uint8Array {\n//             var byteArray = new Uint8Array(str.length * 3);\n//             var offset = 0;\n//             for (var i = 0; i < str.length; i++) {\n//                 var charCode = str.charCodeAt(i);\n//                 var codes = null;\n//                 if (charCode <= 0x7f) {\n//                     codes = [charCode];\n//                 } else if (charCode <= 0x7ff) {\n//                     codes = [0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f)];\n//                 } else {\n//                     codes = [0xe0 | (charCode >> 12), 0x80 | ((charCode & 0xfc0) >> 6), 0x80 | (charCode & 0x3f)];\n//                 }\n//                 for (var j = 0; j < codes.length; j++) {\n//                     byteArray[offset] = codes[j];\n//                     ++offset;\n//                 }\n//             }\n//             var _buffer = new Uint8Array(offset);\n//             copyArray(_buffer, 0, byteArray, 0, offset);\n//             return _buffer;\n//         }\n\n//         /**\n//          * client decode\n//          * msg String data\n//          * return Message Object\n//          */\n//         static strdecode(buffer: ArrayBuffer): string {\n//             var bytes = new Uint8Array(buffer);\n//             var array = [];\n//             var offset = 0;\n//             var charCode = 0;\n//             var end = bytes.length;\n//             while (offset < end) {\n//                 if (bytes[offset] < 128) {\n//                     charCode = bytes[offset];\n//                     offset += 1;\n//                 } else if (bytes[offset] < 224) {\n//                     charCode = ((bytes[offset] & 0x1f) << 6) + (bytes[offset + 1] & 0x3f);\n//                     offset += 2;\n//                 } else {\n//                     charCode = ((bytes[offset] & 0x0f) << 12) + ((bytes[offset + 1] & 0x3f) << 6) + (bytes[offset + 2] & 0x3f);\n//                     offset += 3;\n//                 }\n//                 array.push(charCode);\n//             }\n//             return String.fromCharCode.apply(null, array);\n//         }\n//     }\n\n//     export class Package {\n//         static TYPE_HANDSHAKE = 1;\n//         static TYPE_HANDSHAKE_ACK = 2;\n//         static TYPE_HEARTBEAT = 3;\n//         static TYPE_DATA = 4;\n//         static TYPE_KICK = 5;\n\n//         /**\n//          * Package protocol encode.\n//          *\n//          * Pomelo package format:\n//          * +------+-------------+------------------+\n//          * | type | body length |       body       |\n//          * +------+-------------+------------------+\n//          *\n//          * Head: 4bytes\n//          *   0: package type,\n//          *      1 - handshake,\n//          *      2 - handshake ack,\n//          *      3 - heartbeat,\n//          *      4 - data\n//          *      5 - kick\n//          *   1 - 3: big-endian body length\n//          * Body: body length bytes\n//          *\n//          * @param  {Number}    type   package type\n//          * @param  {Uint8Array} body   body content in bytes\n//          * @return {Uint8Array}        new byte array that contains encode result\n//          */\n//         static encode(type: number, body?: Uint8Array): Uint8Array {\n//             var length = body ? body.length : 0;\n//             var buffer = new Uint8Array(PKG_HEAD_BYTES + length);\n//             var index = 0;\n//             buffer[index++] = type & 0xff;\n//             buffer[index++] = (length >> 16) & 0xff;\n//             buffer[index++] = (length >> 8) & 0xff;\n//             buffer[index++] = length & 0xff;\n//             if (body) {\n//                 copyArray(buffer, index, body, 0, length);\n//             }\n//             return buffer;\n//         }\n\n//         /**\n//          * Package protocol decode.\n//          * See encode for package format.\n//          *\n//          * @param  {Uint8Array} buffer byte array containing package content\n//          * @return {Object}           {type: package type, buffer: body byte array}\n//          */\n//         static decode(buffer: ArrayBuffer): { type: number, body?: Uint8Array } | { type: number, body?: Uint8Array }[] {\n//             var offset = 0;\n//             var bytes = new Uint8Array(buffer);\n//             var length = 0;\n//             var rs = [];\n//             while (offset < bytes.length) {\n//                 var type = bytes[offset++];\n//                 length = ((bytes[offset++]) << 16 | (bytes[offset++]) << 8 | bytes[offset++]) >>> 0;\n//                 var body = length ? new Uint8Array(length) : undefined;\n//                 if (body) {\n//                     copyArray(body, 0, bytes, offset, length);\n//                 }\n//                 offset += length;\n//                 rs.push({ 'type': type, 'body': body });\n//             }\n//             return rs.length === 1 ? rs[0] : rs;\n//         }\n//     }\n\n//     export class Message {\n//         static TYPE_REQUEST = 0;\n//         static TYPE_NOTIFY = 1;\n//         static TYPE_RESPONSE = 2;\n//         static TYPE_PUSH = 3;\n\n//         /**\n//          * Message protocol encode.\n//          *\n//          * @param  {Number} id            message id\n//          * @param  {Number} type          message type\n//          * @param  {Number} compressRoute whether compress route\n//          * @param  {Number|String} route  route code or route string\n//          * @param  {Buffer} msg           message body bytes\n//          * @return {Buffer}               encode result\n//          */\n//         static encode(id: number, type: number, compressRoute: number, route: number | string, msg: Uint8Array): Uint8Array {\n//             // caculate message max length\n//             var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;\n//             var msgLen = MSG_FLAG_BYTES + idBytes;\n\n//             if (msgHasRoute(type)) {\n//                 if (compressRoute) {\n//                     if (typeof route !== 'number') {\n//                         throw new Error('error flag for number route!');\n//                     }\n//                     msgLen += MSG_ROUTE_CODE_BYTES;\n//                 } else {\n//                     msgLen += MSG_ROUTE_LEN_BYTES;\n//                     if (route) {\n//                         let routebuf = Protocol.strencode(route as string);\n//                         if (routebuf.length > 255) {\n//                             throw new Error('route maxlength is overflow');\n//                         }\n//                         msgLen += routebuf.length;\n//                     }\n//                 }\n//             }\n\n//             if (msg) {\n//                 msgLen += msg.length;\n//             }\n\n//             var buffer = new Uint8Array(msgLen);\n//             var offset = 0;\n\n//             // add flag\n//             offset = encodeMsgFlag(type, compressRoute, buffer, offset);\n\n//             // add message id\n//             if (msgHasId(type)) {\n//                 offset = encodeMsgId(id, buffer, offset);\n//             }\n\n//             // add route\n//             if (msgHasRoute(type)) {\n//                 offset = encodeMsgRoute(compressRoute, route, buffer, offset);\n//             }\n\n//             // add body\n//             if (msg) {\n//                 offset = encodeMsgBody(msg, buffer, offset);\n//             }\n\n//             return buffer;\n//         }\n\n//         /**\n//          * Message protocol decode.\n//          *\n//          * @param  {Buffer|Uint8Array} buffer message bytes\n//          * @return {Object}            message object\n//          */\n//         static decode(buffer: string | ArrayBuffer): {\n//             id: number,\n//             type: number,\n//             compressRoute: number,\n//             route: number | string,\n//             body: Uint8Array,\n//             compressGzip: number\n//         } {\n//             var bytes = typeof buffer == 'string' ? new TextEncoder().encode(buffer) : new Uint8Array(buffer);\n//             var bytesLen = bytes.length || bytes.byteLength;\n//             var offset = 0;\n//             var id = 0;\n//             var route: number | string = '';\n\n//             // parse flag\n//             var flag = bytes[offset++];\n//             var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;\n//             var type = (flag >> 1) & MSG_TYPE_MASK;\n//             var compressGzip = (flag >> 4) & MSG_COMPRESS_GZIP_MASK;\n\n//             // parse id\n//             if (msgHasId(type)) {\n//                 var m = 0;\n//                 var i = 0;\n//                 do {\n//                     m = parseInt(bytes[offset] + '');\n//                     id += (m & 0x7f) << (7 * i);\n//                     offset++;\n//                     i++;\n//                 } while (m >= 128);\n//             }\n\n//             // parse route\n//             if (msgHasRoute(type)) {\n//                 if (compressRoute) {\n//                     route = (bytes[offset++]) << 8 | bytes[offset++];\n//                 } else {\n//                     var routeLen = bytes[offset++];\n//                     if (routeLen) {\n//                         let routeBuffer = new Uint8Array(routeLen);\n//                         copyArray(routeBuffer, 0, bytes, offset, routeLen);\n//                         route = Protocol.strdecode(routeBuffer);\n//                     } else {\n//                         route = '';\n//                     }\n//                     offset += routeLen;\n//                 }\n//             }\n\n//             // parse body\n//             var bodyLen = bytesLen - offset;\n//             var body = new Uint8Array(bodyLen);\n\n//             copyArray(body, 0, bytes, offset, bodyLen);\n\n//             return {\n//                 id: id,\n//                 type: type,\n//                 compressRoute: compressRoute,\n//                 route: route,\n//                 body: body,\n//                 compressGzip: compressGzip\n//             }\n//         }\n//     }\n\n//     function copyArray(dest: Uint8Array, doffset: number, src: Uint8Array | string, soffset: number, length: number): void {\n//         // Uint8Array\n//         if (typeof src == 'string') {\n//             for (var index = 0; index < length; index++) {\n//                 dest[doffset++] = parseInt(src[soffset++]);\n//             }\n//         }\n//         else {\n//             for (var index = 0; index < length; index++) {\n//                 dest[doffset++] = src[soffset++];\n//             }\n//         }\n//     };\n\n//     function msgHasId(type: number): boolean {\n//         return type === Message.TYPE_REQUEST || type === Message.TYPE_RESPONSE;\n//     };\n\n//     function msgHasRoute(type: number): boolean {\n//         return type === Message.TYPE_REQUEST || type === Message.TYPE_NOTIFY ||\n//             type === Message.TYPE_PUSH;\n//     };\n\n//     function caculateMsgIdBytes(id: number): number {\n//         var len = 0;\n//         do {\n//             len += 1;\n//             id >>= 7;\n//         } while (id > 0);\n//         return len;\n//     };\n\n//     function encodeMsgFlag(type: number, compressRoute: number, buffer: Uint8Array, offset: number): number {\n//         if (type !== Message.TYPE_REQUEST && type !== Message.TYPE_NOTIFY &&\n//             type !== Message.TYPE_RESPONSE && type !== Message.TYPE_PUSH) {\n//             throw new Error('unkonw message type: ' + type);\n//         }\n\n//         buffer[offset] = (type << 1) | (compressRoute ? 1 : 0);\n\n//         return offset + MSG_FLAG_BYTES;\n//     };\n\n//     function encodeMsgId(id: number, buffer: Uint8Array, offset: number): number {\n//         do {\n//             var tmp = id % 128;\n//             var next = Math.floor(id / 128);\n\n//             if (next !== 0) {\n//                 tmp = tmp + 128;\n//             }\n//             buffer[offset++] = tmp;\n\n//             id = next;\n//         } while (id !== 0);\n\n//         return offset;\n//     };\n\n//     function encodeMsgRoute(compressRoute: number, route: number | string, buffer: Uint8Array, offset: number): number {\n//         if (compressRoute) {\n\n//             if (route > MSG_ROUTE_CODE_MAX) {\n//                 throw new Error('route number is overflow');\n//             }\n\n//             buffer[offset++] = (route as number >> 8) & 0xff;\n//             buffer[offset++] = route as number & 0xff;\n//         } else {\n//             if (route) {\n//                 buffer[offset++] = (route as string).length & 0xff;\n//                 copyArray(buffer, offset, route as string, 0, (route as string).length);\n//                 offset += (route as string).length;\n//             } else {\n//                 buffer[offset++] = 0;\n//             }\n//         }\n\n//         return offset;\n//     };\n\n//     function encodeMsgBody(msg: Uint8Array, buffer: Uint8Array, offset: number): number {\n//         copyArray(buffer, offset, msg, 0, msg.length);\n//         return offset + msg.length;\n//     };\n\n//     const CONNECT_TIMEOUT = 3;\n// }\n"]}